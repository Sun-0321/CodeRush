<html lang="en">

    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

        <meta name="X-Csrf-Token" content="07683b4c33a0837f3e2306e143fb0495">
        <meta id="viewport" name="viewport" content="width=device-width, initial-scale=0.01">


        <script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script>
        <script type="text/javascript" async="" src="http://www.google-analytics.com/ga.js"></script>
        <script type="text/javascript" async=""
            src="./Everything About Dynamic Programming - Codeforces_files/ga.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery-1.8.3.js.download"></script>
        <script type="application/javascript">
            window.standaloneContest = false;
            function adjustViewport() {
                var screenWidthPx = Math.min($(window).width(), window.screen.width);
                var siteWidthPx = 1100; // min width of site
                var ratio = Math.min(screenWidthPx / siteWidthPx, 1.0);
                var viewport = "width=device-width, initial-scale=" + ratio;
                $('#viewport').attr('content', viewport);
                var style = $('<style>html * { max-height: 1000000px; }</style>');
                $('html > head').append(style);
            }

            if (/Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(navigator.userAgent)) {
                adjustViewport();
            }

            /* Protection against trailing dot in domain. */
            let hostLength = window.location.host.length;
            if (hostLength > 1 && window.location.host[hostLength - 1] === '.') {
                window.location = window.location.protocol + "//" + window.location.host.substring(0, hostLength - 1);
            }
        </script>
        <meta http-equiv="pragma" content="no-cache">
        <meta http-equiv="expires" content="-1">
        <meta http-equiv="profileName" content="i2">
        <meta name="google-site-verification" content="OTd2dN5x4nS4OPknPI9JFg36fKxjqY0i1PSfFPv_J90">
        <meta property="fb:admins" content="100001352546622">
        <meta property="og:image" content="//cdn.codeforces.com/s/0/images/codeforces-sponsored-by-ton.png">
        <link rel="image_src" href="https://cdn.codeforces.com/s/0/images/codeforces-sponsored-by-ton.png">
        <meta property="og:title" content="Everything About Dynamic Programming - Codeforces">
        <meta property="og:description" content="">

        <meta property="og:site_name" content="Codeforces">
        <meta name="uc" content="23fadadc6f8f0e96c71a7fcc9864f45a0ae8e5c7">
        <meta name="usmc" content="392511cc34cb611f42eeb788ad497f4f8a59afd5">




        <meta name="utc_offset" content="+03:00">
        <meta name="verify-reformal" content="f56f99fd7e087fb6ccb48ef2">
        <title>Everything About Dynamic Programming - Codeforces</title>
        <meta name="description" content="Codeforces. Programming competitions and contests, programming community">
        <meta name="keywords"
            content="programming algorithm contest competition informatics olympiads c++ java graphs vkcup">
        <meta name="robots" content="index, follow">

        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/font-awesome.min.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/line-awesome.min.css"
            type="text/css" charset="utf-8">

        <link href="./Everything About Dynamic Programming - Codeforces_files/css" rel="stylesheet" type="text/css">
        <link href="./Everything About Dynamic Programming - Codeforces_files/css(1)" rel="stylesheet" type="text/css">


        <link rel="apple-touch-icon" sizes="57x57" href="https://cdn.codeforces.com/s/0/apple-icon-57x57.png">
        <link rel="apple-touch-icon" sizes="60x60" href="https://cdn.codeforces.com/s/0/apple-icon-60x60.png">
        <link rel="apple-touch-icon" sizes="72x72" href="https://cdn.codeforces.com/s/0/apple-icon-72x72.png">
        <link rel="apple-touch-icon" sizes="76x76" href="https://cdn.codeforces.com/s/0/apple-icon-76x76.png">
        <link rel="apple-touch-icon" sizes="114x114" href="https://cdn.codeforces.com/s/0/apple-icon-114x114.png">
        <link rel="apple-touch-icon" sizes="120x120" href="https://cdn.codeforces.com/s/0/apple-icon-120x120.png">
        <link rel="apple-touch-icon" sizes="144x144" href="https://cdn.codeforces.com/s/0/apple-icon-144x144.png">
        <link rel="apple-touch-icon" sizes="152x152" href="https://cdn.codeforces.com/s/0/apple-icon-152x152.png">
        <link rel="apple-touch-icon" sizes="180x180" href="https://cdn.codeforces.com/s/0/apple-icon-180x180.png">
        <link rel="icon" type="image/png" sizes="192x192"
            href="https://cdn.codeforces.com/s/0/android-icon-192x192.png">
        <link rel="icon" type="image/png" sizes="32x32" href="https://cdn.codeforces.com/s/0/favicon-32x32.png">
        <link rel="icon" type="image/png" sizes="96x96" href="https://cdn.codeforces.com/s/0/favicon-96x96.png">
        <link rel="icon" type="image/png" sizes="16x16" href="https://cdn.codeforces.com/s/0/favicon-16x16.png">
        <link rel="manifest" href="https://codeforces.com/manifest.json">
        <meta name="msapplication-TileColor" content="#ffffff">
        <meta name="msapplication-TileImage" content="//cdn.codeforces.com/s/0/ms-icon-144x144.png">
        <meta name="theme-color" content="#ffffff">

        <!--CombineResourcesFilter-->
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/prettify.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/clear.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/style.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/ttypography.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/problem-statement.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/second-level-menu.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/roundbox.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/datatable.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/table-form.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/topic.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/jquery.jgrowl.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/facebox.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/jquery.wysiwyg.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/jquery.autocomplete.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/codeforces.datepick.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/colorbox.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/jquery.drafts.css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/community.css"
            type="text/css" charset="utf-8">

        <!-- MathJax -->
        <script type="text/x-mathjax-config;executed=true">
MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$$$','$$$']], displayMath: [['$$$$$$','$$$$$$']]}
});
MathJax.Hub.Register.StartupHook("End", function () {
    Codeforces.runMathJaxListeners();
});
</script>
        <script type="text/javascript" async=""
            src="./Everything About Dynamic Programming - Codeforces_files/MathJax.js.download">
            </script>
        <!-- /MathJax -->

        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/prettify.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/moment-with-locales.min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/pushstream.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.easing.min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.lavalamp.min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.jgrowl.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.swipe.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.hotkeys.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/facebox.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.wysiwyg.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/wysiwyg.colorpicker.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/wysiwyg.table.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/wysiwyg.image.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/wysiwyg.link.js.download"></script>
        <style type="text/css">
            .MathJax_Preview {
                color: #888;
                display: contents
            }

            #MathJax_Message {
                position: fixed;
                left: 1em;
                bottom: 1.5em;
                background-color: #E6E6E6;
                border: 1px solid #959595;
                margin: 0px;
                padding: 2px 8px;
                z-index: 102;
                color: black;
                font-size: 80%;
                width: auto;
                white-space: nowrap
            }

            #MathJax_MSIE_Frame {
                position: absolute;
                top: 0;
                left: 0;
                width: 0px;
                z-index: 101;
                border: 0px;
                margin: 0px;
                padding: 0px
            }

            .MathJax_Error {
                color: #CC0000;
                font-style: italic
            }
        </style>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.autocomplete.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/ua-parser.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.datepick.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.ie6blocker.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.colorbox-min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.ba-bbq.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.drafts.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/clipboard.min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/autosize.min.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/sjcl.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/codeforces-options.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/codeforces.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/EventCatcher.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/preparedVerdictFormats-en.js.download"></script>
        <!--/CombineResourcesFilter-->

        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/style(1).css"
            type="text/css" charset="utf-8">
        <link rel="stylesheet" href="./Everything About Dynamic Programming - Codeforces_files/style(2).css"
            type="text/css" charset="utf-8">


        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/jquery.markitup.js.download"></script>
        <script type="text/javascript"
            src="./Everything About Dynamic Programming - Codeforces_files/set.js.download"></script>

        <!--[if IE]>
<style>
    #sidebar {
        padding-left: 1em;
        margin: 1em 1em 1em 0;
    }
</style>
<![endif]-->




        <style type="text/css">
            .MathJax_Hover_Frame {
                border-radius: .25em;
                -webkit-border-radius: .25em;
                -moz-border-radius: .25em;
                -khtml-border-radius: .25em;
                box-shadow: 0px 0px 15px #83A;
                -webkit-box-shadow: 0px 0px 15px #83A;
                -moz-box-shadow: 0px 0px 15px #83A;
                -khtml-box-shadow: 0px 0px 15px #83A;
                border: 1px solid #A6D ! important;
                display: inline-block;
                position: absolute
            }

            .MathJax_Menu_Button .MathJax_Hover_Arrow {
                position: absolute;
                cursor: pointer;
                display: inline-block;
                border: 2px solid #AAA;
                border-radius: 4px;
                -webkit-border-radius: 4px;
                -moz-border-radius: 4px;
                -khtml-border-radius: 4px;
                font-family: 'Courier New', Courier;
                font-size: 9px;
                color: #F0F0F0
            }

            .MathJax_Menu_Button .MathJax_Hover_Arrow span {
                display: block;
                background-color: #AAA;
                border: 1px solid;
                border-radius: 3px;
                line-height: 0;
                padding: 4px
            }

            .MathJax_Hover_Arrow:hover {
                color: white !important;
                border: 2px solid #CCC !important
            }

            .MathJax_Hover_Arrow:hover span {
                background-color: #CCC !important
            }
        </style>
        <style type="text/css">
            #MathJax_About {
                position: fixed;
                left: 50%;
                width: auto;
                text-align: center;
                border: 3px outset;
                padding: 1em 2em;
                background-color: #DDDDDD;
                color: black;
                cursor: default;
                font-family: message-box;
                font-size: 120%;
                font-style: normal;
                text-indent: 0;
                text-transform: none;
                line-height: normal;
                letter-spacing: normal;
                word-spacing: normal;
                word-wrap: normal;
                white-space: nowrap;
                float: none;
                z-index: 201;
                border-radius: 15px;
                -webkit-border-radius: 15px;
                -moz-border-radius: 15px;
                -khtml-border-radius: 15px;
                box-shadow: 0px 10px 20px #808080;
                -webkit-box-shadow: 0px 10px 20px #808080;
                -moz-box-shadow: 0px 10px 20px #808080;
                -khtml-box-shadow: 0px 10px 20px #808080;
                filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
            }

            #MathJax_About.MathJax_MousePost {
                outline: none
            }

            .MathJax_Menu {
                position: absolute;
                background-color: white;
                color: black;
                width: auto;
                padding: 2px;
                border: 1px solid #CCCCCC;
                margin: 0;
                cursor: default;
                font: menu;
                text-align: left;
                text-indent: 0;
                text-transform: none;
                line-height: normal;
                letter-spacing: normal;
                word-spacing: normal;
                word-wrap: normal;
                white-space: nowrap;
                float: none;
                z-index: 201;
                box-shadow: 0px 10px 20px #808080;
                -webkit-box-shadow: 0px 10px 20px #808080;
                -moz-box-shadow: 0px 10px 20px #808080;
                -khtml-box-shadow: 0px 10px 20px #808080;
                filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
            }

            .MathJax_MenuItem {
                padding: 2px 2em;
                background: transparent
            }

            .MathJax_MenuArrow {
                position: absolute;
                right: .5em;
                padding-top: .25em;
                color: #666666;
                font-size: .75em
            }

            .MathJax_MenuActive .MathJax_MenuArrow {
                color: white
            }

            .MathJax_MenuArrow.RTL {
                left: .5em;
                right: auto
            }

            .MathJax_MenuCheck {
                position: absolute;
                left: .7em
            }

            .MathJax_MenuCheck.RTL {
                right: .7em;
                left: auto
            }

            .MathJax_MenuRadioCheck {
                position: absolute;
                left: 1em
            }

            .MathJax_MenuRadioCheck.RTL {
                right: 1em;
                left: auto
            }

            .MathJax_MenuLabel {
                padding: 2px 2em 4px 1.33em;
                font-style: italic
            }

            .MathJax_MenuRule {
                border-top: 1px solid #CCCCCC;
                margin: 4px 1px 0px
            }

            .MathJax_MenuDisabled {
                color: GrayText
            }

            .MathJax_MenuActive {
                background-color: Highlight;
                color: HighlightText
            }

            .MathJax_MenuDisabled:focus,
            .MathJax_MenuLabel:focus {
                background-color: #E8E8E8
            }

            .MathJax_ContextMenu:focus {
                outline: none
            }

            .MathJax_ContextMenu .MathJax_MenuItem:focus {
                outline: none
            }

            #MathJax_AboutClose {
                top: .2em;
                right: .2em
            }

            .MathJax_Menu .MathJax_MenuClose {
                top: -10px;
                left: -10px
            }

            .MathJax_MenuClose {
                position: absolute;
                cursor: pointer;
                display: inline-block;
                border: 2px solid #AAA;
                border-radius: 18px;
                -webkit-border-radius: 18px;
                -moz-border-radius: 18px;
                -khtml-border-radius: 18px;
                font-family: 'Courier New', Courier;
                font-size: 24px;
                color: #F0F0F0
            }

            .MathJax_MenuClose span {
                display: block;
                background-color: #AAA;
                border: 1.5px solid;
                border-radius: 18px;
                -webkit-border-radius: 18px;
                -moz-border-radius: 18px;
                -khtml-border-radius: 18px;
                line-height: 0;
                padding: 8px 0 6px
            }

            .MathJax_MenuClose:hover {
                color: white !important;
                border: 2px solid #CCC !important
            }

            .MathJax_MenuClose:hover span {
                background-color: #CCC !important
            }

            .MathJax_MenuClose:hover:focus {
                outline: none
            }
        </style>
        <style type="text/css">
            .MathJax_Preview .MJXf-math {
                color: inherit !important
            }
        </style>
        <style type="text/css">
            .MJX_Assistive_MathML {
                position: absolute !important;
                top: 0;
                left: 0;
                clip: rect(1px, 1px, 1px, 1px);
                padding: 1px 0 0 0 !important;
                border: 0 !important;
                height: 1px !important;
                width: 1px !important;
                overflow: hidden !important;
                display: block !important;
                -webkit-touch-callout: none;
                -webkit-user-select: none;
                -khtml-user-select: none;
                -moz-user-select: none;
                -ms-user-select: none;
                user-select: none
            }

            .MJX_Assistive_MathML.MJX_Assistive_MathML_Block {
                width: 100% !important
            }
        </style>
        <style type="text/css">
            #MathJax_Zoom {
                position: absolute;
                background-color: #F0F0F0;
                overflow: auto;
                display: block;
                z-index: 301;
                padding: .5em;
                border: 1px solid black;
                margin: 0;
                font-weight: normal;
                font-style: normal;
                text-align: left;
                text-indent: 0;
                text-transform: none;
                line-height: normal;
                letter-spacing: normal;
                word-spacing: normal;
                word-wrap: normal;
                white-space: nowrap;
                float: none;
                -webkit-box-sizing: content-box;
                -moz-box-sizing: content-box;
                box-sizing: content-box;
                box-shadow: 5px 5px 15px #AAAAAA;
                -webkit-box-shadow: 5px 5px 15px #AAAAAA;
                -moz-box-shadow: 5px 5px 15px #AAAAAA;
                -khtml-box-shadow: 5px 5px 15px #AAAAAA;
                filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')
            }

            #MathJax_ZoomOverlay {
                position: absolute;
                left: 0;
                top: 0;
                z-index: 300;
                display: inline-block;
                width: 100%;
                height: 100%;
                border: 0;
                padding: 0;
                margin: 0;
                background-color: white;
                opacity: 0;
                filter: alpha(opacity=0)
            }

            #MathJax_ZoomFrame {
                position: relative;
                display: inline-block;
                height: 0;
                width: 0
            }

            #MathJax_ZoomEventTrap {
                position: absolute;
                left: 0;
                top: 0;
                z-index: 302;
                display: inline-block;
                border: 0;
                padding: 0;
                margin: 0;
                background-color: white;
                opacity: 0;
                filter: alpha(opacity=0)
            }
        </style>
        <style type="text/css">
            .MathJax_Preview {
                color: #888;
                display: contents
            }

            #MathJax_Message {
                position: fixed;
                left: 1em;
                bottom: 1.5em;
                background-color: #E6E6E6;
                border: 1px solid #959595;
                margin: 0px;
                padding: 2px 8px;
                z-index: 102;
                color: black;
                font-size: 80%;
                width: auto;
                white-space: nowrap
            }

            #MathJax_MSIE_Frame {
                position: absolute;
                top: 0;
                left: 0;
                width: 0px;
                z-index: 101;
                border: 0px;
                margin: 0px;
                padding: 0px
            }

            .MathJax_Error {
                color: #CC0000;
                font-style: italic
            }
        </style>
        <style type="text/css">
            .MJXp-script {
                font-size: .8em
            }

            .MJXp-right {
                -webkit-transform-origin: right;
                -moz-transform-origin: right;
                -ms-transform-origin: right;
                -o-transform-origin: right;
                transform-origin: right
            }

            .MJXp-bold {
                font-weight: bold
            }

            .MJXp-italic {
                font-style: italic
            }

            .MJXp-scr {
                font-family: MathJax_Script, 'Times New Roman', Times, STIXGeneral, serif
            }

            .MJXp-frak {
                font-family: MathJax_Fraktur, 'Times New Roman', Times, STIXGeneral, serif
            }

            .MJXp-sf {
                font-family: MathJax_SansSerif, 'Times New Roman', Times, STIXGeneral, serif
            }

            .MJXp-cal {
                font-family: MathJax_Caligraphic, 'Times New Roman', Times, STIXGeneral, serif
            }

            .MJXp-mono {
                font-family: MathJax_Typewriter, 'Times New Roman', Times, STIXGeneral, serif
            }

            .MJXp-largeop {
                font-size: 150%
            }

            .MJXp-largeop.MJXp-int {
                vertical-align: -.2em
            }

            .MJXp-math {
                display: inline-block;
                line-height: 1.2;
                text-indent: 0;
                font-family: 'Times New Roman', Times, STIXGeneral, serif;
                white-space: nowrap;
                border-collapse: collapse
            }

            .MJXp-display {
                display: block;
                text-align: center;
                margin: 1em 0
            }

            .MJXp-math span {
                display: inline-block
            }

            .MJXp-box {
                display: block !important;
                text-align: center
            }

            .MJXp-box:after {
                content: " "
            }

            .MJXp-rule {
                display: block !important;
                margin-top: .1em
            }

            .MJXp-char {
                display: block !important
            }

            .MJXp-mo {
                margin: 0 .15em
            }

            .MJXp-mfrac {
                margin: 0 .125em;
                vertical-align: .25em
            }

            .MJXp-denom {
                display: inline-table !important;
                width: 100%
            }

            .MJXp-denom>* {
                display: table-row !important
            }

            .MJXp-surd {
                vertical-align: top
            }

            .MJXp-surd>* {
                display: block !important
            }

            .MJXp-script-box>* {
                display: table !important;
                height: 50%
            }

            .MJXp-script-box>*>* {
                display: table-cell !important;
                vertical-align: top
            }

            .MJXp-script-box>*:last-child>* {
                vertical-align: bottom
            }

            .MJXp-script-box>*>*>* {
                display: block !important
            }

            .MJXp-mphantom {
                visibility: hidden
            }

            .MJXp-munderover,
            .MJXp-munder {
                display: inline-table !important
            }

            .MJXp-over {
                display: inline-block !important;
                text-align: center
            }

            .MJXp-over>* {
                display: block !important
            }

            .MJXp-munderover>*,
            .MJXp-munder>* {
                display: table-row !important
            }

            .MJXp-mtable {
                vertical-align: .25em;
                margin: 0 .125em
            }

            .MJXp-mtable>* {
                display: inline-table !important;
                vertical-align: middle
            }

            .MJXp-mtr {
                display: table-row !important
            }

            .MJXp-mtd {
                display: table-cell !important;
                text-align: center;
                padding: .5em 0 0 .5em
            }

            .MJXp-mtr>.MJXp-mtd:first-child {
                padding-left: 0
            }

            .MJXp-mtr:first-child>.MJXp-mtd {
                padding-top: 0
            }

            .MJXp-mlabeledtr {
                display: table-row !important
            }

            .MJXp-mlabeledtr>.MJXp-mtd:first-child {
                padding-left: 0
            }

            .MJXp-mlabeledtr:first-child>.MJXp-mtd {
                padding-top: 0
            }

            .MJXp-merror {
                background-color: #FFFF88;
                color: #CC0000;
                border: 1px solid #CC0000;
                padding: 1px 3px;
                font-style: normal;
                font-size: 90%
            }

            .MJXp-scale0 {
                -webkit-transform: scaleX(.0);
                -moz-transform: scaleX(.0);
                -ms-transform: scaleX(.0);
                -o-transform: scaleX(.0);
                transform: scaleX(.0)
            }

            .MJXp-scale1 {
                -webkit-transform: scaleX(.1);
                -moz-transform: scaleX(.1);
                -ms-transform: scaleX(.1);
                -o-transform: scaleX(.1);
                transform: scaleX(.1)
            }

            .MJXp-scale2 {
                -webkit-transform: scaleX(.2);
                -moz-transform: scaleX(.2);
                -ms-transform: scaleX(.2);
                -o-transform: scaleX(.2);
                transform: scaleX(.2)
            }

            .MJXp-scale3 {
                -webkit-transform: scaleX(.3);
                -moz-transform: scaleX(.3);
                -ms-transform: scaleX(.3);
                -o-transform: scaleX(.3);
                transform: scaleX(.3)
            }

            .MJXp-scale4 {
                -webkit-transform: scaleX(.4);
                -moz-transform: scaleX(.4);
                -ms-transform: scaleX(.4);
                -o-transform: scaleX(.4);
                transform: scaleX(.4)
            }

            .MJXp-scale5 {
                -webkit-transform: scaleX(.5);
                -moz-transform: scaleX(.5);
                -ms-transform: scaleX(.5);
                -o-transform: scaleX(.5);
                transform: scaleX(.5)
            }

            .MJXp-scale6 {
                -webkit-transform: scaleX(.6);
                -moz-transform: scaleX(.6);
                -ms-transform: scaleX(.6);
                -o-transform: scaleX(.6);
                transform: scaleX(.6)
            }

            .MJXp-scale7 {
                -webkit-transform: scaleX(.7);
                -moz-transform: scaleX(.7);
                -ms-transform: scaleX(.7);
                -o-transform: scaleX(.7);
                transform: scaleX(.7)
            }

            .MJXp-scale8 {
                -webkit-transform: scaleX(.8);
                -moz-transform: scaleX(.8);
                -ms-transform: scaleX(.8);
                -o-transform: scaleX(.8);
                transform: scaleX(.8)
            }

            .MJXp-scale9 {
                -webkit-transform: scaleX(.9);
                -moz-transform: scaleX(.9);
                -ms-transform: scaleX(.9);
                -o-transform: scaleX(.9);
                transform: scaleX(.9)
            }

            .MathJax_PHTML .noError {
                vertical-align: ;
                font-size: 90%;
                text-align: left;
                color: black;
                padding: 1px 3px;
                border: 1px solid
            }
        </style>
        <style type="text/css">
            .MathJax_Display {
                text-align: center;
                margin: 1em 0em;
                position: relative;
                display: block !important;
                text-indent: 0;
                max-width: none;
                max-height: none;
                min-width: 0;
                min-height: 0;
                width: 100%
            }

            .MathJax .merror {
                background-color: #FFFF88;
                color: #CC0000;
                border: 1px solid #CC0000;
                padding: 1px 3px;
                font-style: normal;
                font-size: 90%
            }

            .MathJax .MJX-monospace {
                font-family: monospace
            }

            .MathJax .MJX-sans-serif {
                font-family: sans-serif
            }

            #MathJax_Tooltip {
                background-color: InfoBackground;
                color: InfoText;
                border: 1px solid black;
                box-shadow: 2px 2px 5px #AAAAAA;
                -webkit-box-shadow: 2px 2px 5px #AAAAAA;
                -moz-box-shadow: 2px 2px 5px #AAAAAA;
                -khtml-box-shadow: 2px 2px 5px #AAAAAA;
                filter: progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true');
                padding: 3px 4px;
                z-index: 401;
                position: absolute;
                left: 0;
                top: 0;
                width: auto;
                height: auto;
                display: none
            }

            .MathJax {
                display: inline;
                font-style: normal;
                font-weight: normal;
                line-height: normal;
                font-size: 100%;
                font-size-adjust: none;
                text-indent: 0;
                text-align: left;
                text-transform: none;
                letter-spacing: normal;
                word-spacing: normal;
                word-wrap: normal;
                white-space: nowrap;
                float: none;
                direction: ltr;
                max-width: none;
                max-height: none;
                min-width: 0;
                min-height: 0;
                border: 0;
                padding: 0;
                margin: 0
            }

            .MathJax:focus,
            body :focus .MathJax {
                display: inline-table
            }

            .MathJax.MathJax_FullWidth {
                text-align: center;
                display: table-cell !important;
                width: 10000em !important
            }

            .MathJax img,
            .MathJax nobr,
            .MathJax a {
                border: 0;
                padding: 0;
                margin: 0;
                max-width: none;
                max-height: none;
                min-width: 0;
                min-height: 0;
                vertical-align: 0;
                line-height: normal;
                text-decoration: none
            }

            img.MathJax_strut {
                border: 0 !important;
                padding: 0 !important;
                margin: 0 !important;
                vertical-align: 0 !important
            }

            .MathJax span {
                display: inline;
                position: static;
                border: 0;
                padding: 0;
                margin: 0;
                vertical-align: 0;
                line-height: normal;
                text-decoration: none;
                box-sizing: content-box
            }

            .MathJax nobr {
                white-space: nowrap !important
            }

            .MathJax img {
                display: inline !important;
                float: none !important
            }

            .MathJax * {
                transition: none;
                -webkit-transition: none;
                -moz-transition: none;
                -ms-transition: none;
                -o-transition: none
            }

            .MathJax_Processing {
                visibility: hidden;
                position: fixed;
                width: 0;
                height: 0;
                overflow: hidden
            }

            .MathJax_Processed {
                display: none !important
            }

            .MathJax_test {
                font-style: normal;
                font-weight: normal;
                font-size: 100%;
                font-size-adjust: none;
                text-indent: 0;
                text-transform: none;
                letter-spacing: normal;
                word-spacing: normal;
                overflow: hidden;
                height: 1px
            }

            .MathJax_test.mjx-test-display {
                display: table !important
            }

            .MathJax_test.mjx-test-inline {
                display: inline !important;
                margin-right: -1px
            }

            .MathJax_test.mjx-test-default {
                display: block !important;
                clear: both
            }

            .MathJax_ex_box {
                display: inline-block !important;
                position: absolute;
                overflow: hidden;
                min-height: 0;
                max-height: none;
                padding: 0;
                border: 0;
                margin: 0;
                width: 1px;
                height: 60ex
            }

            .MathJax_em_box {
                display: inline-block !important;
                position: absolute;
                overflow: hidden;
                min-height: 0;
                max-height: none;
                padding: 0;
                border: 0;
                margin: 0;
                width: 1px;
                height: 60em
            }

            .mjx-test-inline .MathJax_left_box {
                display: inline-block;
                width: 0;
                float: left
            }

            .mjx-test-inline .MathJax_right_box {
                display: inline-block;
                width: 0;
                float: right
            }

            .mjx-test-display .MathJax_right_box {
                display: table-cell !important;
                width: 10000em !important;
                min-width: 0;
                max-width: none;
                padding: 0;
                border: 0;
                margin: 0
            }

            .MathJax .MathJax_HitBox {
                cursor: text;
                background: white;
                opacity: 0;
                filter: alpha(opacity=0)
            }

            .MathJax .MathJax_HitBox * {
                filter: none;
                opacity: 1;
                background: transparent
            }

            #MathJax_Tooltip * {
                filter: none;
                opacity: 1;
                background: transparent
            }

            @font-face {
                font-family: MathJax_Main;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Main-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Main-Regular.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Main-bold;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Main-Bold.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Main-Bold.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Main-italic;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Main-Italic.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Main-Italic.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Math-italic;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Math-Italic.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Math-Italic.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Caligraphic;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Size1;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Size1-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Size1-Regular.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Size2;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Size2-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Size2-Regular.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Size3;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Size3-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Size3-Regular.otf?V=2.7.9') format('opentype')
            }

            @font-face {
                font-family: MathJax_Size4;
                src: url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/woff/MathJax_Size4-Regular.woff?V=2.7.9') format('woff'), url('https://cdn-mathjax.codeforces.com/fonts/HTML-CSS/TeX/otf/MathJax_Size4-Regular.otf?V=2.7.9') format('opentype')
            }

            .MathJax .noError {
                vertical-align: ;
                font-size: 90%;
                text-align: left;
                color: black;
                padding: 1px 3px;
                border: 1px solid
            }
        </style>
        <style type="text/css">
            .MathJax_Preview {
                color: #888;
                display: contents
            }

            #MathJax_Message {
                position: fixed;
                left: 1em;
                bottom: 1.5em;
                background-color: #E6E6E6;
                border: 1px solid #959595;
                margin: 0px;
                padding: 2px 8px;
                z-index: 102;
                color: black;
                font-size: 80%;
                width: auto;
                white-space: nowrap
            }

            #MathJax_MSIE_Frame {
                position: absolute;
                top: 0;
                left: 0;
                width: 0px;
                z-index: 101;
                border: 0px;
                margin: 0px;
                padding: 0px
            }

            .MathJax_Error {
                color: #CC0000;
                font-style: italic
            }
        </style>
    </head>

    <body class=" ">
        <div id="MathJax_Message" style="display: none;"></div>
        <div id="MathJax_Message" style="display: none;"></div>
        <div
            style="visibility: hidden; overflow: hidden; position: absolute; top: 0px; height: 1px; width: auto; padding: 0px; border: 0px; margin: 0px; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal;">
            <div id="MathJax_Hidden"></div>
        </div>
        <div id="MathJax_Message" style="display: none;"></div><span style="display:none;" class="csrf-token"
            data-csrf="07683b4c33a0837f3e2306e143fb0495">&nbsp;</span>

        <!-- .notificationTextCleaner used in Codeforces.showAnnouncements() -->
        <div class="notificationTextCleaner" style="font-size: 0"></div>
        <div class="button-up"
            style="opacity: 0.7; width: 30px; height: 100%; position: fixed; left: 0px; top: 0px; cursor: pointer; text-align: center; line-height: 30px; color: rgb(211, 219, 228); font-weight: bold; font-size: 20px; display: block;">
            <i class="icon-circle-arrow-up"></i>
        </div>
        <div class="verdictPrototypeDiv" style="display: none;"></div>

        <!-- Codeforces JavaScripts. -->
        <script type="text/javascript">
            String.prototype.hashCode = function () {
                var hash = 0, i, chr;
                if (this.length === 0) return hash;
                for (i = 0; i < this.length; i++) {
                    chr = this.charCodeAt(i);
                    hash = ((hash << 5) - hash) + chr;
                    hash |= 0; // Convert to 32bit integer
                }
                return hash;
            };

            var queryMobile = Codeforces.queryString.mobile;
            if (queryMobile === "true" || queryMobile === "false") {
                Codeforces.putToStorage("useMobile", queryMobile === "true");
            } else {
                var useMobile = Codeforces.getFromStorage("useMobile");
                if (useMobile === true || useMobile === false) {
                    if (useMobile != false) {
                        Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, "mobile", useMobile));
                    }
                }
            }
        </script>

        <script type="text/javascript">
            if (window.parent.frames.length > 0) {
                window.stop();
            }
        </script>





        <script type="text/javascript">
            $(document).ready(function () {
                (function () {
                    jQuery.expr[':'].containsCI = function (elem, index, match) {
                        return !match || !match.length || match.length < 4 || !match[3] || (
                            elem.textContent || elem.innerText || jQuery(elem).text() || ''
                        ).toLowerCase().indexOf(match[3].toLowerCase()) >= 0;
                    }
                }(jQuery));

                $.ajaxPrefilter(function (options, originalOptions, xhr) {
                    var csrf = Codeforces.getCsrfToken();

                    if (csrf) {
                        var data = originalOptions.data;
                        if (originalOptions.data !== undefined) {
                            if (Object.prototype.toString.call(originalOptions.data) === '[object String]') {
                                data = $.deparam(originalOptions.data);
                            }
                        } else {
                            data = {};
                        }
                        options.data = $.param($.extend(data, { csrf_token: csrf }));
                    }
                });

                window.getCodeforcesServerTime = function (callback) {
                    $.post("/data/time", {}, callback, "json");
                }

                window.updateTypography = function () {
                    $("div.ttypography code").addClass("tt");
                    $("div.ttypography pre>code").addClass("prettyprint").removeClass("tt");
                    $("div.ttypography table").addClass("bordertable");
                    prettyPrint();
                }

                $.ajaxSetup({
                    scriptCharset: "utf-8", contentType: "application/x-www-form-urlencoded; charset=UTF-8", headers: {
                        'X-Csrf-Token': Codeforces.getCsrfToken()
                    }
                });

                window.updateTypography();

                Codeforces.signForms();

                setTimeout(function () {
                    $(".second-level-menu-list").lavaLamp({
                        fx: "backout",
                        speed: 700
                    });
                }, 100);


                Codeforces.countdown();
                $("a[rel='photobox']").colorbox();

                var count = 0;

                function getDelay() {
                    var delay = 0;
                    var last = Codeforces.getFromStorage("LastOnlineTimeUpdaterMillis", 0);
                    if (last && last != null) {
                        var period = count < 20 ? 360 * 1000 : 600 * 1000;
                        delay = period - (new Date().getTime() - last);
                        if (delay < 0)
                            delay = 0;
                    }
                    return delay;
                }

                window.setInterval(function () {
                    if (getDelay() <= 0 && count < 120) {
                        ++count;
                        Codeforces.ping("/data/update-online");
                    }
                }, 5000);

                var handle = "Letscode_sundar";
                $("a.rated-user:contains(" + handle + "), span.participant:contains(" + handle + ")").each(function () {
                    if ($(this).text() == handle) {
                        var td = $(this).parent();
                        var tr = $(this).parent().parent();
                        if (td.is("td") && tr.is("tr") && !tr.hasClass("disable-highlight-self")) {
                            info(handle);
                            tr.addClass("highlighted-row");
                        }
                    }
                });

                function showAnnouncements(json) {
                    //info("j=" + JSON.stringify(json));

                    if (json.t != "a") {
                        return;
                    }

                    setTimeout(function () {
                        Codeforces.showAnnouncements(json.d, "en");
                    }, Math.random() * 500);
                }

                function showEventCatcherUserMessage(json) {
                    if (json.t == "s") {
                        var points = json.d[5];
                        var passedTestCount = json.d[7];
                        var judgedTestCount = json.d[8];
                        var verdict = preparedVerdictFormats[json.d[12]];
                        var verdictPrototypeDiv = $(".verdictPrototypeDiv");
                        verdictPrototypeDiv.html(verdict);
                        if (judgedTestCount != null && judgedTestCount != undefined) {
                            verdictPrototypeDiv.find(".verdict-format-judged").text(judgedTestCount);
                        }
                        if (passedTestCount != null && passedTestCount != undefined) {
                            verdictPrototypeDiv.find(".verdict-format-passed").text(passedTestCount);
                        }
                        if (points != null && points != undefined) {
                            verdictPrototypeDiv.find(".verdict-format-points").text(points);
                        }
                        Codeforces.showMessage(verdictPrototypeDiv.text());
                    }
                }

                $(".clickable-title").each(function () {
                    var title = $(this).attr("data-title");
                    if (title) {
                        var tmp = document.createElement("DIV");
                        tmp.innerHTML = title;
                        $(this).attr("title", tmp.textContent || tmp.innerText || "");
                    }
                });

                $(".clickable-title").click(function () {
                    var title = $(this).attr("data-title");
                    if (title) {
                        Codeforces.alert(title);
                    } else {
                        Codeforces.alert($(this).attr("title"));
                    }
                }).css("position", "relative").css("bottom", "3px");

                Codeforces.showDelayedMessage();

                Codeforces.reformatTimes();

                //Codeforces.initializePubSub();
                if (window.codeforcesOptions.subscribeServerUrl) {
                    window.eventCatcher = new EventCatcher(
                        window.codeforcesOptions.subscribeServerUrl,
                        [
                            Codeforces.getGlobalChannel(),
                            Codeforces.getUserChannel(),
                            Codeforces.getUserShowMessageChannel(),
                            Codeforces.getContestChannel(),
                            Codeforces.getParticipantChannel(),
                            Codeforces.getTalkChannel()
                        ]
                    );

                    if (Codeforces.getParticipantChannel()) {
                        window.eventCatcher.subscribe(Codeforces.getParticipantChannel(), function (json) {
                            showAnnouncements(json);
                        });
                    }

                    if (Codeforces.getContestChannel()) {
                        window.eventCatcher.subscribe(Codeforces.getContestChannel(), function (json) {
                            showAnnouncements(json);
                        });
                    }

                    if (Codeforces.getGlobalChannel()) {
                        window.eventCatcher.subscribe(Codeforces.getGlobalChannel(), function (json) {
                            showAnnouncements(json);
                        });
                    }

                    if (Codeforces.getUserChannel()) {
                        window.eventCatcher.subscribe(Codeforces.getUserChannel(), function (json) {
                            showAnnouncements(json);
                        });
                    }

                    if (Codeforces.getUserShowMessageChannel()) {
                        window.eventCatcher.subscribe(Codeforces.getUserShowMessageChannel(), function (json) {
                            showEventCatcherUserMessage(json);
                        });
                    }
                }

                Codeforces.setupContestTimes("/data/contests");
                Codeforces.setupSpoilers();
                Codeforces.setupTutorials("/data/problemTutorial");
            });
        </script>

        <script type="text/javascript">
            var _gaq = _gaq || [];
            _gaq.push(['_setAccount', 'UA-743380-5']);
            _gaq.push(['_trackPageview']);

            (function () {
                var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
                ga.src = (document.location.protocol == 'https:' ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
                var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
            })();
        </script>


        <div id="body">
            <script type="application/javascript">
                window.setTimeout(function () {
                    var url = location.href;
                    var hashCode32 = Math.abs(url.hashCode()).toString();
                    var hashCode = "p" + hashCode32 + Math.abs((hashCode32 + url).hashCode());
                    var pvs = Codeforces.getFromStorage("pvs" + hashCode);
                    if (!pvs) {
                        $.post("/data/apv", {
                            ftaa: window._ftaa,
                            bfaa: window._bfaa,
                            url: url
                        }, function (json) {
                            if (json["success"] === "true") {
                                Codeforces.putToStorage("pvs" + hashCode, true);
                            }
                        }, "json");
                    }
                }, 5000);
            </script>


            <div class="side-bell"
                style="visibility: hidden; opacity: 0.7; width: 30px; position: fixed; right: 0px; top: 0px; cursor: pointer; text-align: center; line-height: 30px; color: rgb(211, 219, 228); font-weight: bold; font-size: 10px; display: block;">
                <span class="icon-stack" style="width: 100%;">
                    <i class="icon-circle icon-stack-base"></i>
                    <i class="icon-bell-alt icon-light"></i>
                </span>
                <br>
                <span class="side-bell__count" style="position: relative; top: -10px;"></span>
            </div>




            <style>
                .header-bell {
                    display: inline-block;
                    position: relative;
                    cursor: pointer;
                }

                .header-bell__img {
                    opacity: 0.5;
                    background-image: url("//cdn.codeforces.com/s/57914/images/icons/bell_inactive-20x20.png");
                    position: relative;
                    bottom: 1px;
                    width: 20px;
                    height: 20px;
                }

                .header-bell__img-active {
                    opacity: 1 !important;
                    background-image: url("//cdn.codeforces.com/s/57914/images/icons/bell_active-20x20.png") !important;
                }

                .header-bell__count {
                    position: absolute;
                    top: 8px;
                    left: 18px;
                    font-weight: bold;
                    font-size: 10px;
                }

                .bell-details {
                    display: none;
                    z-index: 5;
                    border: 1px solid rgb(185, 185, 185);
                    width: 40rem;
                    max-height: 60rem;
                    padding: 0;
                    position: absolute;
                    top: 20px;
                    right: 0;
                    background-color: white;
                    overflow: scroll;
                    overflow-x: hidden;
                    overflow-y: auto;
                }

                .bell-details.sidebar-bell {
                    position: fixed;
                    right: 50px;
                }

                .bell-details__no-new {
                    font-size: 1.3rem;
                    display: block;
                    text-align: center;
                    color: #888 !important;
                    padding: 1em;
                }

                .bell-details__recent-link {
                    margin: 0;
                    padding: 0.5em;
                    text-align: center;
                    border-top: 1px solid rgb(185, 185, 185);
                }

                .bell-details__recent-link a {
                    font-size: 1.2rem;
                }

                .bell-details__proto-row-comment {
                    display: none;
                }

                .bell-details__proto-row-blog-entry {
                    display: none;
                }

                .bell-details__proto-row-comment-reply {
                    display: none;
                }

                .bell-details__row {
                    text-align: left;
                    margin: 0.5em;
                    padding: 0.25em 0.25em 0.75em 0.25em;
                    clear: both;
                }

                .bell-details__row:hover {
                    cursor: pointer;
                    background-color: #def;
                }

                .bell-details__row-active {
                    background-color: #def;
                }

                .bell-details__thumbnail-a {
                    text-decoration: none;
                }

                .bell-details__row img {
                    zoom: 50%;
                    margin-right: 2em;
                    float: left;
                }

                .bell-details__comment {
                    padding-left: 45px;
                    font-size: 1.3rem;
                }

                .bell-details__blog-entry {
                    padding-left: 45px;
                    font-size: 1.3rem;
                }

                .bell-details__comment-reply {
                    padding-left: 45px;
                    font-size: 1.3rem;
                }

                .bell-details__time {
                    padding-left: 45px;
                    margin-top: 0.2em;
                    font-size: 1.1rem;
                    color: #888 !important;
                }
            </style>

            <script>
                $(function () {
                    if ($(window).width() < 1600) {
                        $('.side-bell').css('width', '30px').css('line-height', '30px').css('font-size', '10px');
                    }

                    if ($(window).width() >= 1200) {
                        $(window).scroll(function () {
                            if ($(this).scrollTop() > 100) {
                                $(".bell-details").addClass("sidebar-bell");
                                $('.side-bell').fadeIn();
                            } else {
                                $(".bell-details").removeClass("sidebar-bell");
                                $('.side-bell').fadeOut();
                            }
                        });

                        $('.side-bell').hover(function () {
                            $(this).animate({
                                'opacity': '1'
                            }).css({ 'color': '#6a86a4' });
                        }, function () {
                            $(this).animate({
                                'opacity': '0.7'
                            }).css({ 'color': '#d3dbe4' });
                        });
                    }

                    $(".lang-chooser>div:first-child").prepend($("<span style='position: relative; bottom: 8px; padding: 0 0.5em;'>|</span>")).prepend($(".header-bell").show());
                    function Bell() {
                        var bell = this;
                        var notifications = JSON.parse("[]");

                        bell.notifications = {};

                        for (var i in notifications) {
                            if (notifications.hasOwnProperty(i)) {
                                bell.notifications[notifications[i].id] = notifications[i];
                            }
                        }

                        function onClick(notification) {
                            var notificationIds = [];
                            var reason = notification.data.reasonType + "#" + notification.reasonId;
                            for (id in bell.notifications) {
                                if (bell.notifications.hasOwnProperty(id)) {
                                    var otherNotification = bell.notifications[id];
                                    var otherReason = otherNotification.data.reasonType + "#" + otherNotification.reasonId;
                                    if (otherReason == reason) {
                                        notificationIds.push(otherNotification.id);
                                    }
                                }
                            }
                            $.post("/data/notification", { action: "markAsRead", notificationIds: notificationIds.join(",") }, function (result) {
                                Codeforces.redirect(notification.data.url);
                            }, "json");
                        }

                        var $bellDetails = $(".bell-details");
                        bell.newCommentRow = function (notification) {
                            var row = $(".bell-details__proto-row-comment").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__comment").html(
                                "ReasonUser mentioned you in a comment".replace("ReasonUser", notification.data.reasonUserHtml)
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-comment");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };
                        bell.newFriendCommentRow = function (notification) {
                            var row = $(".bell-details__proto-row-comment").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__comment").html(
                                "ReasonUser wrote a comment".replace("ReasonUser", notification.data.reasonUserHtml)
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-comment");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };
                        bell.newCommentReplyRow = function (notification) {
                            var row = $(".bell-details__proto-row-comment-reply").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__comment-reply").html(
                                "ReasonUser replied to your comment".replace("ReasonUser", notification.data.reasonUserHtml)
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-comment-reply");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };
                        bell.newBlogEntryRow = function (notification) {
                            var row = $(".bell-details__proto-row-blog-entry").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__blog-entry").html(
                                "ReasonUser mentioned you in a blog entry".replace("ReasonUser", notification.data.reasonUserHtml)
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-blog-entry");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };
                        bell.newFriendBlogEntryRow = function (notification) {
                            var row = $(".bell-details__proto-row-blog-entry").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__blog-entry").html(
                                "ReasonUser wrote a blog entry".replace("ReasonUser", notification.data.reasonUserHtml)
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-blog-entry");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };
                        bell.newProposalCommentRow = function (notification) {
                            var row = $(".bell-details__proto-row-comment-reply").clone();
                            row.addClass("bell-details__row").attr("data-notificationId", notification.id);
                            row.find(".bell-details__thumbnail-a").attr("href", notification.data.reasonUserUrl);
                            row.find("img").attr("src", notification.data.reasonUserThumbnailUrl);
                            row.find(".bell-details__comment-reply").html(
                                "ReasonUser commented on ProposalType Proposal".replace("ReasonUser", notification.data.reasonUserHtml)
                                    .replace("ProposalType", "Contest" == notification.data.proposalType ? "contest proposal" : "problem proposal")
                                    .replace("Proposal", $("<div/>").text(notification.data.proposalName).html())
                            );
                            row.find(".bell-details__time").html(
                                "<span class='format-systemtimewithseconds'>"
                                + notification.creationTimeString
                                + "</span>"
                            );
                            row.removeClass("bell-details__proto-row-comment-reply");
                            row.click(function () {
                                onClick(notification);
                                return false;
                            });
                            return row;
                        };

                        bell.renderRow = function (notification) {
                            var $row = $(".bell-details__row[data-notificationId='" + notification.id + "']");

                            if ($bellDetails.css("display") != "block" && notification.read) {
                                $row.hide();
                                return;
                            }

                            notification.data = JSON.parse(notification.dataJson);

                            var reason = notification.data.reasonType + "#" + notification.reasonId;

                            var has = false;
                            $row.each(function () {
                                has = true;
                            });
                            if ($(".bell-details__row[data-reason='" + reason + "']").length) {
                                has = true;
                            }

                            if (!has) {
                                $(".side-bell").css("visibility", "visible");
                                var newRow;
                                if (notification.type == "Comment") {
                                    newRow = bell.newCommentRow(notification);
                                } else if (notification.type == "BlogEntry") {
                                    newRow = bell.newBlogEntryRow(notification);
                                } else if (notification.type == "CommentReply") {
                                    newRow = bell.newCommentReplyRow(notification);
                                } else if (notification.type == "FriendComment") {
                                    newRow = bell.newFriendCommentRow(notification);
                                } else if (notification.type == "FriendBlogEntry") {
                                    newRow = bell.newFriendBlogEntryRow(notification);
                                } else if (notification.type == "ProposalComment") {
                                    newRow = bell.newProposalCommentRow(notification)
                                }
                                if (newRow) {
                                    newRow.attr("data-reason", reason);
                                    $(".bell-details").prepend(newRow);
                                }
                            }
                        };

                        var $count = $(".header-bell__count, .side-bell__count");
                        var $img = $(".header-bell__img");
                        var $noNew = $(".bell-details__no-new");

                        bell.renewCount = function () {
                            Codeforces.reformatTimes();
                            var count = 0;
                            var counted = {};
                            for (var id in bell.notifications)
                                if (bell.notifications.hasOwnProperty(id)) {
                                    var notification = bell.notifications[id];
                                    if (notification) {
                                        var reason = notification.data.reasonType + "#" + notification.reasonId;
                                        if (!notification.read && !counted[reason]) {
                                            count++;
                                            counted[reason] = true;
                                        }
                                    }
                                }
                            if (count > 0) {
                                $count.text(count);
                                $img.addClass("header-bell__img-active");
                                $noNew.hide();
                            } else {
                                $count.text("");
                                $img.removeClass("header-bell__img-active");
                                if ($bellDetails.css("display") != "block") {
                                    $noNew.show();
                                }
                            }
                        };

                        for (var id in bell.notifications)
                            if (bell.notifications.hasOwnProperty(id))
                                bell.renderRow(bell.notifications[id]);

                        if (window.eventCatcher) {
                            window.eventCatcher.subscribe(Codeforces.getUserChannel(), function (json) {
                                if (json.t === "n") {
                                    for (var i in json.d)
                                        if (json.d.hasOwnProperty(i)) {
                                            var notification = json.d[i];
                                            notification.data = JSON.parse(notification.dataJson);
                                            bell.notifications[notification.id] = notification;
                                            bell.renderRow(notification);
                                            bell.renewCount();
                                        }
                                }
                            });
                        }


                        $(".header-bell, .side-bell").click(function () {
                            if ($bellDetails.css("display") == "none") {
                                for (var id in bell.notifications)
                                    if (bell.notifications.hasOwnProperty(id))
                                        if (bell.notifications[id].read)
                                            bell.renderRow(bell.notifications[id]);
                                bell.renewCount();

                                $bellDetails.css("display", "block");

                                var notificationIds = [];
                                for (id in bell.notifications)
                                    if (bell.notifications.hasOwnProperty(id))
                                        notificationIds.push(id);

                                setTimeout(function () {
                                    if ($bellDetails.css("display") == "block") {
                                        $.post("/data/notification", { action: "markAsRead", notificationIds: notificationIds.join(",") }, function (result) {
                                            // No operations.
                                        }, "json");

                                        for (var i in notificationIds) {
                                            if (notificationIds.hasOwnProperty(i)) {
                                                bell.notifications[notificationIds[i]].read = true;
                                            }
                                        }
                                        bell.renewCount();
                                    }
                                }, 2000);
                            } else {
                                var has = false;
                                for (var id in bell.notifications) {
                                    if (bell.notifications.hasOwnProperty(id) && !bell.notifications[id].read) {
                                        has = true;
                                    }
                                }
                                if (!has) {
                                    $(".side-bell").css("visibility", "hidden");
                                }
                                $bellDetails.css("display", "none");
                                bell.renewCount();
                            }
                        });
                    }

                    bell = new Bell();
                    bell.renewCount();
                })
            </script>






            <script type="text/javascript">
                $(document).ready(function () {
                    $("input.search").focus(function () {
                        if ($(this).attr("data-isPlaceholder") === "true") {
                            $(this).val("");
                            $(this).removeAttr("data-isPlaceholder");
                        }
                    });
                });
            </script>
            <br style="height: 3em; clear: both;">

            <div style="position: relative;">

                <div id="pageContent" class="content-with-sidebar">

                    <div style="margin-top:0;">
                        <div>

                        </div>
                        <div style="margin-top:2em;">


                            <div class="topic" topicid="43366">
                                <div class="title">
                                    <a href="https://codeforces.com/blog/entry/43256">
                                        <p>Everything About Dynamic Programming</p>
                                    </a>
                                </div>



                                <div class="content">
                                    <div class="ttypography">
                                        <p><strong>I decided to gather some good material on the web related to DP and
                                                found some good explanation by svg on topcoder forums..Hence wrote this
                                                blog.Will format it when i get time.</strong></p>
                                        <p><img alt=" "
                                                src="./Everything About Dynamic Programming - Codeforces_files/5a52ed3cdbd62bfd1bad0a7fb1f8a74d768c60ca.png"
                                                style="max-width: 100.0%;max-height: 100.0%;"></p>
                                        <p><strong>Problem:</strong></p>
                                        <p>About 25% of all SRM problems have the "Dynamic Programming" category tag.
                                            The DP problems are popular among problemsetters because each DP problem is
                                            original in some sense and you have to think hard to invent the solution for
                                            it. Since dynamic programming is so popular, it is perhaps the most
                                            important method to master in algorithm competitions.</p>
                                        <p>The easiest way to learn the DP principle is by examples. The current recipe
                                            contains a few DP examples, but unexperienced reader is advised to refer to
                                            other DP tutorials to make the understanding easier. You can find a lot of
                                            DP examples and explanations in an excellent tutorial Dynamic Programming:
                                            From novice to advanced by Dumitru. The purpose of the recipe is to cover
                                            general DP aspects.</p>
                                        <p><strong>Solution</strong></p>
                                        <p><strong>Tutorial (coins example)</strong></p>
                                        <p>So what is exactly the dynamic programming, how can we describe it? There’s
                                            no clear definition for this technique. It can be rather characterized as an
                                            algorithmic technique that is usually based on a starting state of the
                                            problem, and a recurrent formula or relation between the successive states.
                                            A state of the problem usually represents a sub-solution, i.e. a partial
                                            solution or a solution based on a subset of the given input. And the states
                                            are built one by one, based on the previously built states.</p>
                                        <p>Let’s now consider a very simple problem that will help to understand better
                                            the details that will be further discussed: Given a list of n coins, their
                                            weights W1, W2, ..., Wn; and the total sum S. Find the minimum number of
                                            coins the overall weight of which is S (we can use as many coins of each
                                            type as we want), or report that it is not possible to select coins in such
                                            a way so that they sum up to S. This problem is a special case of the famous
                                            unbounded knapsack problem. For this problem a state, let’s call it (P) or
                                            (P)-&gt;k, would represent the solution for a partial sum (P), where P is
                                            not greater than S. k is minimal number of coins required to get exact
                                            overall weight P. The k value is usually called the result of corresponding
                                            state (P).</p>
                                        <p>A dynamic programming solution would thus start with an initial state (0) and
                                            then will build the succeeding states based on the previously found ones. In
                                            the above problem, a state (Q) that precedes (P) would be the one for which
                                            sum Q is lower than P, thus representing a solution for a sum smaller than
                                            P. One starts with the trivial state (0), and then builds the state (P1),
                                            (P2), (P3), and so on until the final state (S) is built, which actually
                                            represents the solution of the problem. One should note that a state can not
                                            be processed until all of the preceding states haven’t been processed – this
                                            is another important characteristic of DP technique.</p>
                                        <p>The last, but not least, detail to discuss is about finding the relation
                                            between states that would allow us to build the next states. For simple
                                            problems this relation is quite easy to be observed, but for complex
                                            problems we may need to do some additional operations or changes to reach
                                            such a relation. Let’s again consider the sample problem described above.
                                            Consider a sum P of coin weights V1, V2, ..., Vj. The state with sum P can
                                            only be reached from a smaller sum Qi by adding a coin Ui to it so that Qi +
                                            Ui = P. Thus there is a limited amount of states which would lead to the
                                            succeeding state (P). The minimum number of coins that can sum up to P is
                                            thus equal to the number of coins of one of the states (Qi), plus one coin,
                                            the coin Ui.</p>
                                        <p>Implementation-wise, the DP results are usually stored in an array. In our
                                            coin example the array "mink[0..S]" contains k values for states. In other
                                            words, mink[P] = k means that result of state (P) is equal to k. The array
                                            of DP results is calculated in a loop (often nested loops) in some order.
                                            The following piece of code contains recurrent equations for the problem,
                                            table of results (contents of array mink) and the solution itself.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Recurrent equations for DP:
{k[0] = 0;
{k[P] = min_i (k[P-Wi] + 1);   (for Wi &lt;= P)
*/</span><span class="pln">
</span><span class="com">/* Consider the input data: S=11, n=3, W = {1,3,5}
The DP results table is:
P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
------+--+--+--+--+--+--+--+--+--+--+--
k = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
*/</span><span class="pln">
</span><span class="com">// The implementation:</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> S</span><span class="pun">;</span><span class="pln">                                        </span><span class="com">//n &amp;mdash; number of coin types, S &amp;mdash; desired overall weight</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> wgt</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">                                   </span><span class="com">//array of coin weights (W); for example: {1, 3, 5};</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">MAXW</span><span class="pun">];</span><span class="pln">                                  </span><span class="com">//array of DP results (k); look above for the example;</span><span class="pln">

mink</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                                   </span><span class="com">//base of DP: 0 weight can be achieved by 0 coins</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> P </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> P</span><span class="pun">&lt;=</span><span class="pln">S</span><span class="pun">;</span><span class="pln"> P</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                   </span><span class="com">//iterate through all the states</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> minres </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln">                    
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">wgt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;=</span><span class="pln"> P</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">//suppose that the coin with weight wgt[i] is the last</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> tres </span><span class="pun">=</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">P </span><span class="pun">&amp;</span><span class="pln">mdash</span><span class="pun">;</span><span class="pln"> wgt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">           </span><span class="com">//the number of coins with the coin is greater by one</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">minres </span><span class="pun">&gt;</span><span class="pln"> tres</span><span class="pun">)</span><span class="pln"> minres </span><span class="pun">=</span><span class="pln"> tres</span><span class="pun">;</span><span class="pln">          </span><span class="com">//choose the minimal overall number of coins among all cases</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
mink</span><span class="pun">[</span><span class="pln">P</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> minres</span><span class="pun">;</span><span class="pln">                            </span><span class="com">//store the result in mink array</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">S</span><span class="pun">];</span><span class="pln">                          </span><span class="com">//the answer for the whole problem is the result for state (S)</span></code></pre>
                                        <p><strong>Tutorial (LCS example)</strong></p>
                                        <p>Consider another problem: given two words, find the length of their longest
                                            common subsequence. For example, for two words "quetzalcoatl" and
                                            "tezcatlipoca" the longest subsequence has length 6, f.i. "ezaloa".</p>
                                        <p>To solve the problem we introduce the set of subproblems: given a prefix of
                                            the first word and a prefix of the second word, find their LCS. Let the
                                            prefix of the first word has length i and the prefix of the second word has
                                            length j. As we see, the DP state is determined by two integer parameters: i
                                            and j. The state domain is therefore (i,j)-&gt;L, where i is the length of
                                            first word prefix, j is the length of second word prefix and L is the length
                                            of the longest common subsequence of these prefixes. The idea of solution is
                                            to take the solution for basic subproblem (0,0) and then add letters to the
                                            prefixes one-by-one until we reach the final state (n1,n2) which represents
                                            the problem for the full words.</p>
                                        <p>Now let's derive the recurrent relations for DP results denoted as L[i,j].
                                            Clearly, if one of the prefixes is empty, then the LCS must be zero. This is
                                            a base equation: L[i,0] = L[0,j] = 0. When i and j are positive then we have
                                            to treat several cases: 1. The last letter in the first word prefix is not
                                            used in the LCS. So it can be erased without changing the subsequence. The
                                            corresponding formula is L[i,j] = L[i-1,j]. 2. The last letter in the second
                                            word prefix is unused. Similarly, the formula for the case is: L[i,j] =
                                            L[i,j-1] 3. Otherwise, last letters 's' and 't' of both prefixes are
                                            included in the common subsequence. Clearly, these letters must be equal. In
                                            such a case erasing both last letters will reduce LCS by exactly one. The
                                            corresponding formula is: L[i,j] = L[i-1,j-1] + 1 (only if 's' = 't'). Among
                                            all three cases we should choose the case which gives the maximal length of
                                            sequence.</p>
                                        <p>Implementation-wise, the DP results are stored in two-dimensional array. The
                                            values of this array are calculated in two nested loops. It is important
                                            that the states are traversed in such order that parameter values are
                                            non-decreasing because the DP result for the state (i,j) depends on the
                                            results for states (i-1,j), (i,j-1), (i-1,j-1).</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Recurrent relations for DP:
{L[i,0] = L[0,j] = 0;
|            {L[i-1,j],
{L[i,j] = max|L[i,j-1],
           {L[i-1,j-1]+1   (only if last symbols are equal)
*/</span><span class="pln">
</span><span class="com">/* Table of DP results:
S|    t  e  z  c  a  t  l  i  p  o  c  a 
T ji| 0  1  2  3  4  5  6  7  8  9 10 11 12
----+--------------------------------------
0 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
q 1 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
u 2 | 0  0  0  0  0  0  0  0  0  0  0  0  0 
e 3 | 0  0  1  1  1  1  1  1  1  1  1  1  1 
t 4 | 0  1  1  1  1  1  2  2  2  2  2  2  2 
z 5 | 0  1  1  2  2  2  2  2  2  2  2  2  2 
a 6 | 0  1  1  2  2  3  3  3  3  3  3  3  3 
l 7 | 0  1  1  2  2  3  3  4  4  4  4  4  4 
c 8 | 0  1  1  2  3  3  3  4  4  4  4  5  5 
o 9 | 0  1  1  2  3  3  3  4  4  4  5  5  5 
a 10| 0  1  1  2  3  4  4  4  4  4  5  5  6 
t 11| 0  1  1  2  3  4  5  5  5  5  5  5  6 
l 12| 0  1  1  2  3  4  5  6  6  6  6  6  6 
*/</span><span class="pln">
</span><span class="com">// The implementation:</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> n1</span><span class="pun">,</span><span class="pln"> n2</span><span class="pun">;</span><span class="pln">                                              </span><span class="com">//lengths of words</span><span class="pln">
</span><span class="kwd">char</span><span class="pln"> str1</span><span class="pun">[</span><span class="lit">1024</span><span class="pun">],</span><span class="pln"> str2</span><span class="pun">[</span><span class="lit">1024</span><span class="pun">];</span><span class="pln">                             </span><span class="com">//input words</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> lcs</span><span class="pun">[</span><span class="lit">1024</span><span class="pun">][</span><span class="lit">1024</span><span class="pun">];</span><span class="pln">                                     </span><span class="com">//DP results array</span><span class="pln">

</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;=</span><span class="pln">n1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">                            </span><span class="com">//iterate through all states (i,j)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;=</span><span class="pln">n2</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                        </span><span class="com">//in lexicographical order</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> j </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln">
    lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                                   </span><span class="com">//the DP base case</span><span class="pln">
  </span><span class="kwd">else</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">],</span><span class="pln"> lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">       </span><span class="com">//handle cases 1 and 2</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">str1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> str2</span><span class="pun">[</span><span class="pln">j</span><span class="pun">-</span><span class="lit">1</span><span class="pun">])</span><span class="pln">
      lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">],</span><span class="pln"> lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">-</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln"> </span><span class="com">//handle case 3</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> lcs</span><span class="pun">[</span><span class="pln">n1</span><span class="pun">][</span><span class="pln">n2</span><span class="pun">];</span></code></pre>
                                        <p><strong>Discussion</strong></p>
                                        <p><strong>Comparison with memoization</strong></p>
                                        <p>There is another technique called memoization which is covered in detail by
                                            recipe "Optimizing recursive solution". Recursive solution with memoization
                                            is very similar to backward-style dynamic programming solution. Both methods
                                            solve recurrent equations, which means that they deal with state domain —
                                            set of states with some result defined. The results for some states are
                                            determined from base of recurrence. The results for other states depend on
                                            the results of previous states. The DP solution iterates through the states
                                            in some particular order set by coder, while memoization iterates through
                                            them in order of depth-first search. DP never calculates the DP result for
                                            any state twice, just like the recursive solution with full memoization. The
                                            memoization approach does not spend time on unnecessary states — it is a
                                            lazy algorithm. Only the states which influence the final answer are
                                            processed. Here are the pros and cons of memoization over DP: 1[+].
                                            Sometimes easier to code. 2[+]. Does not require to specify order on states
                                            explicitly. 3[+]. Processes only necessary states. 4[-]. Works only in the
                                            backward-style DP. 5[-]. Works a bit slower than DP (by constant).</p>
                                        <p>Most of DP problems can be divided into two types: optimization problems and
                                            combinatoric problems. The optimization problems require you to choose some
                                            feasible solution so that the value of goal function is minimized (or
                                            maximized). Combinatoric problems request the number of ways to do something
                                            or the probability of some event. Let's have a closer look at these problem
                                            types.</p>
                                        <p><strong>Optimization DP problem</strong></p>
                                        <p>Optimization problem asks to choose the best feasible solution according to
                                            some goal function. Both coins and LCS examples are optimization-type. The
                                            recurrent equation looks like R[s] = min(F1(R[i], R[j], ..., R[k]), F2(R[u],
                                            R[v], ..., R[w]), ..., Fl(R[q], R[p], ..., R[z])), where R is the DP results
                                            array. Simply speaking, the result is chosen as the best = minimal among the
                                            several candidate cases. For each case the result is calculated from the
                                            results of previous DP states. For example in coins problem all the possible
                                            last coin cases are considered. Each of them yields one case in the
                                            recurrent formula. The result for the state is a minimum among all such
                                            cases. In LCS example there were three cases: first word last letter unused,
                                            second word last letter unused and both words last letter used.</p>
                                        <p>It is often useful to fill the DP results array with neutral values before
                                            calculating anything. The neutral value is a result which does not affect
                                            the problem answer for sure. In case of minimization problem the neutral
                                            value is positive infinity: since it is greater than any number, all the
                                            recurrent formulas would prefer a case with finite value to such a neutral
                                            element. In other words, the state with neutral value result can be thought
                                            of as an impossible state. Note that for maximization problem negative
                                            infinity is a neutral element.</p>
                                        <p>The DP states are often called DP subproblems because they represent some
                                            problem for input data which is subset of the whole problem input. For
                                            example, in LCS case each subproblem involves two arbitrary prefixes of the
                                            original two words. The DP method relies on the optimal substructure
                                            property: given the optimal solution for the whole problem, its partial
                                            solutions must be optimal for the subproblems. In the coins case it means
                                            that if the solution for whole problem with overall weight S is optimal and
                                            it contains coin with weight w, then the solution without w coin must also
                                            be optimal for the subproblem with overall weight (S — w).</p>
                                        <p>Optimal substructure property is very important: if it does not hold and the
                                            optimal solution has the subsolution which is not optimal, then it would be
                                            discarded somewhere in the middle of DP on taking the minimum. Often the DP
                                            solution turns out to be theoretically wrong because it lacks the optimal
                                            substructure. For example there is a classical travelling salesman problem.
                                            Let the DP state domain be (k,l)-&gt;D where D is the minimal length of the
                                            simple path going through exactly k cities with 0-th city being the first
                                            one and l-th city being the last one. The optimal substructure property in
                                            such a DP does not hold: given the shortest tour its subpath with fixed last
                                            city and overall number of cities is not always the shortest. Therefore the
                                            proposed DP would be wrong anyway.</p>
                                        <p><strong>Combinatoric DP problem</strong></p>
                                        <p>The goal of combinatoric DP problem is to find number of ways to do something
                                            or the probability that the event happens. Often the number of ways can be
                                            big and only the reminder modulo some small number is required. The
                                            recurrent equation looks like R[s] = F1(R[i], R[j], ..., R[k]) + F2(R[u],
                                            R[v], ..., R[w]) + ... + Fl(R[q], R[p], ..., R[z]). The only difference from
                                            optimization case is the sum instead of minimum — and it changes a lot. The
                                            summation means that the different ways from F1, F2, ..., Fl cases
                                            altogether comprise the all the ways for state (s).</p>
                                        <p>The example of combinatoric case is a modified coins problem: count the
                                            number of ways to choose coins so that their overall weight is equal to S.
                                            The state domain is the same: (P)-&gt;k where k is number of ways to choose
                                            coins so that their overall weight is exactly P. The recurrent equations are
                                            only a bit different in combinatoric problem.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Recurrent equations for DP:
{k[0] = 1;
{k[P] = sum_i (k[P-Wi]);   (for Wi &lt;= P)
*/</span><span class="pln">
</span><span class="com">/* Consider the input data: S=11, n=3, W = {1,3,5}
The DP results table is:
P = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
------+--+--+--+--+--+--+--+--+--+--+--
k = 1 |1 |1 |2 |3 |5 |8 |12|19|30|47|74
*/</span></code></pre>
                                        <p>There is also a neutral value for combinatoric problem. Since combinatoric
                                            problem uses summation, the neutral element is zero. The DP results in
                                            combinatoric case usually represents number of ways to do smth, so if the
                                            result is zero than there is no way to do it. The neutral result value means
                                            that the case is impossible. It may be useful to fill DP results array with
                                            zero values, though it is usually done automatically. In case of
                                            combinatorics it is important that each possible way is counted and that no
                                            way is counted more than once. The second condition is sometimes difficult
                                            to satisfy.</p>
                                        <p><strong>Forward vs backward DP style</strong></p>
                                        <p>All the DPs described above are done in backward style. The schema is:
                                            iterate through all the states and for each of them calculate the result by
                                            looking backward and using the already known DP results of previous states.
                                            This style can also be called recurrent since it uses recurrent equations
                                            directly for calculation. The relations for backward-style DP are obtained
                                            by examining the best solution for the state and trying to decompose it to
                                            lesser states.</p>
                                        <p>There is also forward-style DP. Surprisingly it is often more convenient to
                                            use. The paradigm of this style is to iterate through all the DP states and
                                            from each state perform some transitions leading forward to other states.
                                            Each transition modifies the currently stored result for some unprocessed
                                            states. When the state is considered, its result is already determined
                                            completely. The forward formulation does not use recurrent equations, so it
                                            is more complex to prove the correctness of solution strictly
                                            mathematically. The recurrent relations used in forward-style DP are
                                            obtained by considering one partial solution for the state and trying to
                                            continue it to larger states. To perform forward-style DP it is necessary to
                                            fill the DP results with neutral values before starting the calculation.</p>
                                        <p>The first example will be combinatoric coins problem. Suppose that you have a
                                            partial solution with P overall weight. Then you can add arbitrary coin with
                                            weight Wi and get overall weight P+Wi. So you get a transition from state
                                            (P) to state (P+Wi). When this transition is considered, the result for
                                            state (P) is added to the result of state (P+Wi) which means that all the
                                            ways to get P weight can be continued to the ways to get P+Wi weight by
                                            adding i-th coin. Here is the code.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Recurrent relations (transitions) of DP:
{k[0] = 1;
{(P)-&gt;k ===&gt; (P+Wi)-&gt;nk    add k to nk
*/</span><span class="pln">
</span><span class="com">//res array is automatically filled with zeroes</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                                 </span><span class="com">//DP base is the same</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln">                   </span><span class="com">//iterate through DP states</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">               </span><span class="com">//iterate through coin to add</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> np </span><span class="pun">=</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> wgt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">                    </span><span class="com">//the new state is (np)</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">np </span><span class="pun">&gt;</span><span class="pln"> s</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                   </span><span class="com">//so the transition is (p) ==&gt; (np)</span><span class="pln">
  res</span><span class="pun">[</span><span class="pln">np</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">p</span><span class="pun">];</span><span class="pln">                      </span><span class="com">//add the DP result of (p) to DP result of (np)</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">];</span><span class="pln">                        </span><span class="com">//problem answer is the same</span></code></pre>
                                        <p>The second example is longest common subsequence problem. It is of
                                            maximization-type, so we have to fill the results array with negative
                                            infinities before calculation. The DP base is state (0,0)-&gt;0 which
                                            represents the pair of empty prefixes. When we consider partial solution
                                            (i,j)-&gt;L we try to continue it by three ways: 1. Add the next letter of
                                            first word to the prefix, do not change subsequence. 2. Add the next letter
                                            of the second word to the prefix, do not change subsequence. 3. Only if the
                                            next letters of words are the same: add next letter to both prefixes and
                                            include it in the subsequence. For each transition we perform so-called
                                            relaxation of the larger DP state result. We look at the currently stored
                                            value in that state: if it is worse that the proposed one, then it is
                                            replaced with the proposed one, otherwise it is not changed. The
                                            implementation code and compact representation of DP relations are given
                                            below.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Recurrent relations (transitions) of DP:
{L[0,0] = 0;
|          /&gt; (i+1,j)-&gt;relax(L)
{(i,j)-&gt;L ==&gt; (i,j+1)-&gt;relax(L)
         \&gt; (i+1,j+1)-&gt;relax(L+1)  (only if next symbols are equal)
*/</span><span class="pln">
</span><span class="kwd">void</span><span class="pln"> relax</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                   </span><span class="com">//relaxation routine</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">a </span><span class="pun">&lt;</span><span class="pln"> b</span><span class="pun">)</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> b</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

memset</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">));</span><span class="pln">              </span><span class="com">//fill the DP results array with negative infinity</span><span class="pln">
lcs</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                              </span><span class="com">//set DP base: (0,0)-&gt;0</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;=</span><span class="pln">n1</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;=</span><span class="pln">n2</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">             </span><span class="com">//iterate through all states</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> tres </span><span class="pun">=</span><span class="pln"> lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
  relax</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">],</span><span class="pln"> tres</span><span class="pun">);</span><span class="pln">               </span><span class="com">//try transition of type 1</span><span class="pln">
  relax</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">+</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> tres</span><span class="pun">);</span><span class="pln">               </span><span class="com">//try transition of type 2</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">str1</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> str2</span><span class="pun">[</span><span class="pln">j</span><span class="pun">])</span><span class="pln">                 </span><span class="com">//and if next symbols are the same</span><span class="pln">
    relax</span><span class="pun">(</span><span class="pln">lcs</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">j</span><span class="pun">+</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> tres </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln">       </span><span class="com">//then try transition of type 3</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> lcs</span><span class="pun">[</span><span class="pln">n1</span><span class="pun">][</span><span class="pln">n2</span><span class="pun">];</span></code></pre>
                                        <p><strong>Recovering the best solution for optimization problems</strong></p>
                                        <p>The optimization problem asks us to find the feasible solution with the
                                            minimal value of goal function, but DP finds only the goal function value
                                            itself. It does not produce the best solution along with the numerical
                                            answer. In practical usage the answer without a solution is useless, though
                                            in topcoder algorithm problems often only the answer is required. Anyway, it
                                            is useful to know how to reconstruct the best solution after DP.</p>
                                        <p>In the most common case the each transition is an atomic improvement of some
                                            partial solution and recurrent equation is something like: R[s] =
                                            min(F1(R[u], u), F2(R[v], v), ..., Fk(R[w], w)). In other words, the result
                                            for the state is produced from a single best previous state plus some
                                            modification. In such a case the DP solution can be reconstructed trivially
                                            from the DP solution path. The DP solution path goes from some base DP state
                                            to some final state and consists of the states which represent all the
                                            partial solutions of the desired best solution. There are two ways to get
                                            this path.</p>
                                        <p>The first way is to recalculate the DP from the end to the start. First we
                                            choose the final state (f) we want to trace the path from. Then we process
                                            the (f) state just like we did it in the DP: iterate through all the
                                            variants to get it. Each variant originates in a previous state (p). If the
                                            variant produces the result equal to DP result of state (f), then the
                                            variant if possible. There is always at least one possible variant to
                                            produce the DP result for the state, though there can be many of them. If
                                            the variant originating from (p) state is possible, then there is at least
                                            one best solution path going through state (p). Therefore we can move to
                                            state (p) and search the path from starting state to state (p) now. We can
                                            end path tracing when we reach the starting state.</p>
                                        <p>Another way is to store back-links along with the DP result. For each state
                                            (s) we save the parameters of the previous state (u) that was continued.
                                            When we perform a transition (u) ==&gt; (s) which produces better result
                                            than the currently stored in (s) then we set the back-link to (s) to the
                                            state (u). To trace the DP solution path we need simply to repeatedly move
                                            to back-linked state until the starting state is met. Note that you can
                                            store any additional info about the way the DP result was obtained to
                                            simplify solution reconstruction.</p>
                                        <p>The first approach has a lot of drawbacks. It is usually slower, it leads to
                                            DP code being copy/pasted, it requires backward-style DP for tracing the
                                            path. It is good only in the rare case when there is not enough memory to
                                            store the back-links required in the second way. The second way is preferred
                                            since it is simple to use and supports both backward and forward style DP
                                            solutions. If the result for each DP state originates from more than one
                                            previous DP state, then you can store the links to all the previous states.
                                            The path reconstruction is easiest to implement in the recursive way in such
                                            a case.</p>
                                        <p>For example of recovering the solution coins problem is again considered.
                                            Note that the DP code is almost the same except that the back-link and item
                                            info is set on the relaxation. The later part of tracing the path back is
                                            rather simple.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">/* Consider the input data: S=11, n=3, W = {1,3,5}
The DP results + back-links table is:
P  = 0 |1 |2 |3 |4 |5 |6 |7 |8 |9 |10|11
-------+--+--+--+--+--+--+--+--+--+--+--
mink = 0 |1 |2 |1 |2 |1 |2 |3 |2 |3 |2 |3
prev = ? |S0|S1|S0|S1|S0|S1|S2|S3|S4|S5|S6
item = ? |I0|I0|I1|I1|I2|I2|I2|I2|I2|I2|I2
*/</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">MAXW</span><span class="pun">];</span><span class="pln">                       </span><span class="com">//the DP result array</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> prev</span><span class="pun">[</span><span class="pln">MAXW</span><span class="pun">],</span><span class="pln"> item</span><span class="pun">[</span><span class="pln">MAXW</span><span class="pun">];</span><span class="pln">           </span><span class="com">//prev &amp;mdash; array for back-links to previous state</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> k</span><span class="pun">;</span><span class="pln">                                </span><span class="com">//item &amp;mdash; stores the last item index</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> sol</span><span class="pun">[</span><span class="pln">MAXW</span><span class="pun">];</span><span class="pln">                        </span><span class="com">//sol[0,1,2,...,k-1] would be the desired solution</span><span class="pln">

memset</span><span class="pun">(</span><span class="pln">mink</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">mink</span><span class="pun">));</span><span class="pln">     </span><span class="com">//fill the DP results with positive infinity</span><span class="pln">
mink</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                        </span><span class="com">//set DP base (0)-&gt;0</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln">           </span><span class="com">//iterate through all states</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">       </span><span class="com">//try to add one item</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> np </span><span class="pun">=</span><span class="pln"> p </span><span class="pun">+</span><span class="pln"> wgt</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">            </span><span class="com">//from (P)-&gt;k we get</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> nres </span><span class="pun">=</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">         </span><span class="com">//to (P+Wi)-&gt;k+1</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mink</span><span class="pun">[</span><span class="pln">np</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> nres</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">          </span><span class="com">//DP results relaxation</span><span class="pln">
    mink</span><span class="pun">[</span><span class="pln">np</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nres</span><span class="pun">;</span><span class="pln">              </span><span class="com">//in case of success</span><span class="pln">
    prev</span><span class="pun">[</span><span class="pln">np</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> p</span><span class="pun">;</span><span class="pln">                 </span><span class="com">//save the previous state</span><span class="pln">
    item</span><span class="pun">[</span><span class="pln">np</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln">                 </span><span class="com">//and the used last item</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> mink</span><span class="pun">[</span><span class="pln">s</span><span class="pun">];</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> cp </span><span class="pun">=</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">                         </span><span class="com">//start from current state S</span><span class="pln">
</span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cp </span><span class="pun">!=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                   </span><span class="com">//until current state is zero</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> pp </span><span class="pun">=</span><span class="pln"> prev</span><span class="pun">[</span><span class="pln">cp</span><span class="pun">];</span><span class="pln">                </span><span class="com">//get the previous state from back-link</span><span class="pln">
sol</span><span class="pun">[</span><span class="pln">k</span><span class="pun">++]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> item</span><span class="pun">[</span><span class="pln">cp</span><span class="pun">];</span><span class="pln">              </span><span class="com">//add the known item to solution array</span><span class="pln">
cp </span><span class="pun">=</span><span class="pln"> pp</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//move to the previous state</span><span class="pln">
</span><span class="pun">}</span></code></pre>
                                        <p>The coins tutorial was taken from Dumitru's DP recipe.</p>
                                        <p><strong>Problem</strong></p>
                                        <p>The correct dynamic programming solution for the problem is already invented.
                                            And perhaps already coded. But the time/space complexity is unsatisfactory.
                                            The solution exceeds time or memory limit or seems to exceed it if it is not
                                            implemented yet. The purpose of recipe is do describe various tricks used to
                                            optimize DP solutions.</p>
                                        <p><strong>Solution</strong></p>
                                        <p>Most of DP problems are combinatorial or optimization type. In first case we
                                            are asked to calculate number of ways to do something, so to get result for
                                            a state we have to sum up several formulas that depend on previous results.
                                            In second case we need to find solution with minimal value of goal function,
                                            and the result for a state is calculated by taking minimum over several
                                            formulas which again depend on the previous results. Depending on the type
                                            of problem, the main operation will be summation or taking minimum — it will
                                            be important in some optimizations.</p>
                                        <p><strong>Consolidate equivalent states</strong></p>
                                        <p>Actually, it is not DP optimization but the main principle of DP. Any
                                            recursive solution which has lots of equivalent states can benefit from
                                            using DP. If there are no equivalent states in recursive solution, turning
                                            it into dynamic programming is useless.</p>
                                        <p>Let's consider some state domain (s)-&gt;R which contains two particular
                                            states x and y. Intuitively these states are equivalent if the problem
                                            answer depends on them in the same way. In other words, there is no
                                            difference between these states with respect to the final problem answer. If
                                            state domain of DP contains lots of groups of equivalent states, then DP
                                            parameters are likely to be redundant. All the equivalence classes can be
                                            merged into single states. If the problem is combinatorial, then the result
                                            for consolidated state must be sum of all results over the merged group of
                                            states. If the problem is minimization, the result must be minimum of
                                            results of states merged. This way the new state domain (less in size) can
                                            be defined. After it is defined, you need to write the transition relations
                                            between new states.</p>
                                        <p>Consider TSP problem as an example. The bruteforce recursive solution
                                            searches over all simple paths from city 0 recursively. State of this
                                            solution is any simple path which starts from city 0. In this way a state
                                            domain is defined and the recursive relations for them are obvious. But then
                                            we can notice that states (0,A,B,L) and (0,B,A,L) are equivalent. It does
                                            not matter in what order the internal cities were visited — only the set of
                                            visited cities and the last city matter. It means that our state domain is
                                            redundant, so let's merge the groups of equivalent states. We will get state
                                            domain (S,L)-&gt;R where S is set of visited states, L is the last city in
                                            the path and R is the minimal possible length of such path. The recursive
                                            solution with O((N-1)!) states is turned into DP over subsets with O(2^N*N)
                                            states.</p>
                                        <p><strong>Prune impossible states</strong></p>
                                        <p>The state is impossible if its result is always equal to zero(combinatorial)
                                            / infinity(minimization). Deleting such a state is a good idea since it does
                                            not change problem answer for sure. The impossible states can come from
                                            several sources:</p>
                                        <p><strong>1. Explicit parameter dependence.</strong> The state domain is (A,B)
                                            and we know that for all possible states B = f(A) where f is some function
                                            (usually analytic and simple). In such a case B parameter means some
                                            unnecessary information and can be deleted from state description. The state
                                            domain will be just (A). If we ever need parameter B to perform a
                                            transition, we can calculate it as f(A). As the result the size of state
                                            domain is decreased dramatically.</p>
                                        <p><strong>2. Implicit parameter dependence.</strong> This case is worse. We
                                            have state domain (A,B) where A represents some parameters and we know that
                                            for any possible state f(A,B) = 0. In other words, for each possible state
                                            some property holds. The best idea is of course to express one of parameters
                                            as explicitly dependent on the others. Then we can go to case 1 and be
                                            happy=) Also if we know that B is either f1(A) or f2(A) or f3(A) or ... or
                                            fk(A) then we can change state domain from (A,B) to (A,i) where i=1..k is a
                                            number of equation B variant. If nothing helps, we can always use approach
                                            4.</p>
                                        <p><strong>3. Inequalities on parameters.</strong> The common way to exploit
                                            inequalities for parameters is to set tight loop bounds. For example, if
                                            state domain is (i,j) and i&lt;j then we can write for(i=0;i&lt;N;i++)
                                            for(j=i+1;j&lt;N;j++) or for(j=0;j&lt;N;j++) for(i=0;i&lt;j;i++). In this
                                            case we avoid processing impossible states and average speedup is x(2). If
                                            there are k parameters which are non-decreasing, speedup will raise to
                                            x(k!).</p>
                                        <p><strong>4. No-thinking ways.</strong> Even if it is difficult to determine
                                            which states are impossible, the fact of their existence itself can be
                                            exploited. There are several ways:</p>
                                        <p>A. Discard impossible states and do not process them. Just add something like
                                            "if (res[i][j]==0) continue;" inside loop which iterates over DP states and
                                            you are done. This optimization should be always used because overhead is
                                            tiny but speedup can be substantial. It does not decrease size of state
                                            domain but saves time from state processing.</p>
                                        <p>B. Use recursive search with memoization. It will behave very similar to DP
                                            but will process only possible states. The decision to use it must be made
                                            before coding starts because the code differs from DP code a lot.</p>
                                        <p>C. Store state results in a map. This way impossible states do not eat memory
                                            and time at all. Unfortunately, you'll have to pay a lot of time complexity
                                            for this technique: O(log(N)) with ordered map and slow O(1) with unordered
                                            map. And a big part of code must be rewritten to implement it.&gt;</p>
                                        <p><strong>Store results only for two layers of DP state domain</strong></p>
                                        <p>It is helpful when the DP is layered. It means that state domain has form
                                            (i,A) where i is layer index and A is additional parameters. Moreover,
                                            transition rules depend only on two adjacent layers. The usual case is when
                                            result for state (i,A) is dependent only on results for states (i-1,*). In
                                            such a DP only two neighbouring layers can be stored in memory. Results for
                                            each layer are discarded after the next one is calculated. The memory is
                                            then reused for the next layer and so on.</p>
                                        <p>Memory contains two layers only. One of them is current layer and another one
                                            is previous layer (in case of forward DP one layer is current and another is
                                            next). After current layer is fully processed, layers are swapped. There is
                                            no need to swap their contents, just swap their pointers/references. Perhaps
                                            the easiest approach is to always store even-numbered layers in one memory
                                            buffer(index 0) and odd-numbered layers in another buffer(index 1). To
                                            rewrite complete and working DP solution to use this optimization you need
                                            to do only: 1. In DP results array definition, change the first size of
                                            array to two. 2. Change indexation [i] to [i&amp;1] in all accesses to this
                                            array. (i&amp;1 is equal to i modulo 2). 3. In forward DP clear the next
                                            layer contents immediately after loop over layer index i. Here is the code
                                            example of layered forward-style minimization DP: ~~~~~ int res[2][MAXK];
                                            //note that first dimension is only 2 for (int i = 0; i&lt;N; i++) {
                                            memset(res[(i+1)&amp;1], 63, sizeof(res[0])); //clear the contents of next
                                            layer (set to infinity) for (int j = 0; j&lt;=K; j++) { //iterate through
                                            all states as usual int ni = i + 1; //layer index of transition destination
                                            is fixed int nj, nres = DPTransition(res[i&amp;1][j], ???); //get additional
                                            parameters and results somehow if (res[ni&amp;1][nj] &gt; nres) //relax
                                            destination result res[ni&amp;1][nj] = nres; //note &amp;1 in first index }
                                            } ~~~~~</p>
                                        <p>This technique reduces memory requirement in O(N) times which is often
                                            necessary to achieve desired space complexity. If sizeof(res) reduces to no
                                            more than several mebibytes, then speed performance can increase due to
                                            cache-friendly memory accesses.</p>
                                        <p>Sometimes you have to store more than two layers. If DP transition relations
                                            use not more that k subsequent layers, then you can store only k layers in
                                            memory. Use modulo k operation to get the array index for certain layer just
                                            like &amp;1 is used in the example.</p>
                                        <p>There is one problem though. In optimization problem there is no simple way
                                            to recover the path(solution) of DP. You will get the goal function of best
                                            solution, but you won't get the solution itself. To recover solution in
                                            usual way you have to store all the intermediate results.</p>
                                        <p>There is a general trick which allows to recover path without storing all the
                                            DP results. The path can be recovered using divide and conquer method.
                                            Divide layers into approximately two halves and choose the middle layer with
                                            index m in between. Now expand the result of DP from (i,A)-&gt;R to
                                            (i,A)-&gt;R,mA where mA is the "middle state". It is value of additional
                                            parameter A of the state that lies both on the path and in the middle layer.
                                            Now let's see the following: 1. After DP is over, problem answer is
                                            determined as minimal result in final layer (with certain properties maybe).
                                            Let this result be R,mA. Then (m,mA) is the state in the middle of the path
                                            we want to recover. 2. The results mA can be calculated via DP. Now we know
                                            the final and the middle states of the desired path. Divide layers into two
                                            halves and launch the same DP for each part recursively. Choose final state
                                            as answer for the right half and middle state as answer for the left half.
                                            Retrieve two states in the middle of these halves and continue recursively.
                                            This technique requires additional O(log(N)) time complexity because result
                                            for each layer is recalculated approximately log(N) times. If some
                                            additional DP parameter is monotonous (for each transition (i,A) — (i+1,B)
                                            inequality A&lt;=B holds) then domain of this parameter can also be divided
                                            into two halves by the middle point. In such a case asymptotic time
                                            complexity does not increase at all.</p>
                                        <p><strong>Precalculate</strong></p>
                                        <p>Often DP solution can benefit from precalculating something. Very often the
                                            precalculation is simple DP itself.</p>
                                        <p>A lot of combinatorial problems require precalculation of binomial
                                            coefficients. You can precalculate prefix sums of an array so that you can
                                            calculate sum of elements in segment in O(1) time. Sometimes it is
                                            beneficial to precalculate first k powers of a number.</p>
                                        <p>Although the term precalculation refers to the calculations which are going
                                            before the DP, a very similar thing can be done in the DP process. For
                                            example, if you have state domain (a,b)-&gt;R you may find it useful to
                                            create another domain (a,k)-&gt;S where S is sum of all R(a,b) with b&lt;k.
                                            It is not precisely precalculation since it expands the DP state domain, but
                                            it serves the same goal: spend some additional time for the ability to
                                            perform a particular operation quickly.&gt;</p>
                                        <p><strong>Rotate the optimization problem</strong></p>
                                        <p>There is a DP solution with state domain (W,A)-&gt;R for maximization
                                            problem, where W is weight of partial solution, A is some additional
                                            parameter and R is maximal value of partial solution that can be achieved.
                                            The simple problem unbounded knapsack problem will serve as an example for
                                            DP rotation.</p>
                                        <p>Let's place additional requirement on the DP: if we increase weight W of
                                            partial solution without changing other parameters including result the
                                            solution worsens. Worsens means that the solution with increased weight can
                                            be discarded if the initial solution is present because the initial solution
                                            leads to better problem answer than the modified one. Notice that the
                                            similar statement must true for result R in any DP: if we increase the
                                            result R of partial solution the solution improves. In case of knapsack
                                            problem the requirement is true: we have some partial solution; if another
                                            solution has more weight and less value, then it is surely worse than the
                                            current one and it is not necessary to process it any further. The
                                            requirement may be different in sense of sign (minimum/maximum.
                                            worsens/improves).</p>
                                        <p>This property allows us to state another "rotated" DP: (R,A)-&gt;W where R is
                                            the value of partial solution, A is the same additional parameter, and W is
                                            the minimal possible weight for such a partial solution. In case of knapsack
                                            we try to take items of exactly R overall value with the least overall
                                            weight possible. The transition for rotated DP is performed the same way.
                                            The answer for the problem is obtained as usual: iterate through all states
                                            (R,A)-&gt;W with desired property and choose solution with maximal value.
                                        </p>
                                        <p>To understand the name of the trick better imagine a grid on the plane with
                                            coordinates (W,R) where W is row index and R is column index. As we see, the
                                            DP stores only the result for rightmost(max-index) cell in each row. The
                                            rotated DP will store only the uppermost(min-index) cell in each column.
                                            Note the DP rotation will be incorrect if the requirement stated above does
                                            not hold.</p>
                                        <p>The rotation is useful only if the range of possible values R is much less
                                            than the range of possible weights W. The state domain will take O(RA)
                                            memory instead of O(WA) which can help sometimes. For example consider the
                                            0-1 knapsack problem with arbitrary positive real weights and values. DP is
                                            not directly applicable in this case. But rotated DP can be used to create
                                            fully polynomial approximation scheme which can approximate the correct
                                            answer with relative error not more than arbitrary threshold. The idea is to
                                            divide all values by small eps and round to the nearest integer. Then solve
                                            DP with state domain (k,R)-&gt;W where k is number of already processed
                                            items, R is overall integer value of items and W is minimal possible overall
                                            weight. Note that you cannot round weights in knapsack problem because the
                                            optimal solution you obtain this way can violate the knapsack size
                                            constraint.</p>
                                        <p><strong>Calculate matrix power by squaring</strong></p>
                                        <p>This technique deals with layered combinatorial DP solution with transition
                                            independent of layer index. Two-layered DP has state domain (i,A)-&gt;R and
                                            recurrent rules in form R(i+1,A) = sum(R(i,B)*C(B)) over all B parameter
                                            values. It is important that recurrent rules does not depend on the layer
                                            index.</p>
                                        <p>Let's create a vector V(i) = (R(i,A1), R(i,A2), ..., R(i,Ak)) where Aj
                                            iterates through all possible values of A parameter. This vector contains
                                            all the results on i-th layer. Then the transition rule can be formulated as
                                            matrix multiplication: V(i+1) = M * V(i) where M is transition matrix. The
                                            answer for the problem is usually determined by the results of last layer,
                                            so we need to calculate V(N) = M^N * V(0).</p>
                                        <p>The DP solution is to get V(0) and then multiply it by M matrix N times. It
                                            requires O(N * A^2) time complexity, or more precisely it requires O(N * Z)
                                            time where Z is number of non-zero elements of matrix M. Instead of
                                            one-by-one matrix multiplication, exponentiation by squaring can be used. It
                                            calculates M^N using O(log(N)) matrix multiplications. After the matrix
                                            power is available, we multiply vector V(0) by it and instantly get the
                                            results for last layer. The overall time complexity is O(A^3 * log(N)). This
                                            trick is necessary when A is rather small (say 200) and N is very large (say
                                            10^9).</p>
                                        <p><strong>Use complex data structures and algorithms</strong></p>
                                        <p>Sometimes tough DP solutions can be accelerated by using complex acceleration
                                            structures or algorithms. Binary search, segment trees (range minimum/sum
                                            query), binary search tree (map) are good at accelerating particular
                                            operations. If you are desperate at inventing DP solution of Div1 1000
                                            problem with proper time complexity, it may be a good idea to recall these
                                            things.</p>
                                        <p>For example, longest increasing subsequence problem DP solution can be
                                            accelerated to O(N log(N)) with dynamic range minimum query data structure
                                            or with binary search depending on the chosen state domain.</p>
                                        <p><strong>Examples</strong></p>
                                        <p><strong>ConnectTheCities</strong></p>
                                        <p>According to the problem statement, each transmitter can be moved to any
                                            location without constraints. But it is useless to change order of
                                            transmitters. It can be proven as follows: if you have solution where two
                                            transmitters change order, swap their final destinations and number of moves
                                            won't increase for sure but the connectivity will remain the same. So we can
                                            assume that in optimal solution transmitters are placed in the same order as
                                            they stay initially.</p>
                                        <p>In DP solution we place transmitters one-by-one from left to right. Besides
                                            number of transmitters already placed, we need to store the position of
                                            foremost transmitter. This information is necessary to check connectivity of
                                            our chain. Also not to exceed move limit we have to include number of moves
                                            made so far into the state of DP. The state domain is (k,f,m)-&gt;r where k
                                            is number of already placed leftmost transmitters, f is position of front
                                            transmitter, m is number of moves made and r is minimal transmittion range
                                            necessary to maintain connectivity. Transition is performed by setting the
                                            k-th transmitter to some p coordinate which is greater or equal to f. This
                                            transmitter becomes foremost one, transmission range can be increased to (p
                                            — f) if necessary and number of moves increases by |p — X[k]|. The problem
                                            answer is produced by considering all possible placements of all n
                                            transmitters and trying to connect the last one to the city B. This DP
                                            solution is O(N * D^2 * M) where N is number of transmitters, D is distance
                                            between cities and M is maximum number of moves allowed.</p>
                                        <p>It is easy to see that if the number of moves m done so far increases then
                                            the partial solution worsens because the remaining limit on moves decreases
                                            and the set of possible continuations narrows. So we can rotate the DP
                                            problem with parameters m and r. The new state domain is (k,f,r)-&gt;m where
                                            r is exact transmitter range required for connectivity and m is minimal
                                            number of used moves possible with such parameters. The transition as an
                                            operation on (k,f,r,m)-tuple remains the exactly same. When we calculate the
                                            problem answer we do the same things but also we check that the number of
                                            moves does not exceed the limit. The rotated DP is O(N * D^3) in time and
                                            can be done in O(D^2) space complexity if "store two layers" optimization is
                                            used.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> n</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">;</span><span class="pln">                                           </span><span class="com">//number of transmitters and distance between cities</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> res</span><span class="pun">[</span><span class="lit">2</span><span class="pun">][</span><span class="pln">MAXD</span><span class="pun">][</span><span class="pln">MAXD</span><span class="pun">];</span><span class="pln">                             </span><span class="com">//state domain results: (k,f,r)-&gt;m</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
sort</span><span class="pun">(</span><span class="pln">xarr</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> xarr</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">());</span><span class="pln">                 </span><span class="com">//do not forget to sort the transmitter positions!</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">));</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                               </span><span class="com">//DP base: all zeros possible, others impossible</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                     </span><span class="com">//iterate k &amp;mdash; number of transmitters places so far</span><span class="pln">
  memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]));</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> f </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> f</span><span class="pun">&lt;=</span><span class="pln">d</span><span class="pun">;</span><span class="pln"> f</span><span class="pun">++)</span><span class="pln">                    </span><span class="com">//iterate f &amp;mdash; position of foremost(and last) transmitter</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> r</span><span class="pun">&lt;=</span><span class="pln">d</span><span class="pun">;</span><span class="pln"> r</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                </span><span class="com">//iterate r &amp;mdash; required transmission range</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">k</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">f</span><span class="pun">][</span><span class="pln">r</span><span class="pun">];</span><span class="pln">                   </span><span class="com">//get minimal number of moves required</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m </span><span class="pun">&gt;</span><span class="pln"> maxmoves</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">               </span><span class="com">//discard state if it is impossible or number of moves exceeds the limit</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> f</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;=</span><span class="pln">d</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln">                </span><span class="com">//iterate p &amp;mdash; possible position of k-th transmitter</span><span class="pln">
        relax</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">max</span><span class="pun">(</span><span class="pln">r</span><span class="pun">,</span><span class="pln">p</span><span class="pun">-</span><span class="pln">f</span><span class="pun">)],</span><span class="pln"> m </span><span class="pun">+</span><span class="pln"> abs</span><span class="pun">(</span><span class="pln">p</span><span class="pun">-</span><span class="pln">xarr</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]));</span><span class="pln"> </span><span class="com">//try transition</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln">                        </span><span class="com">//getting answer as minimal possible r</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> f </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> f</span><span class="pun">&lt;=</span><span class="pln">d</span><span class="pun">;</span><span class="pln"> f</span><span class="pun">++)</span><span class="pln">                      </span><span class="com">//over all states with k = n</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> r</span><span class="pun">&lt;=</span><span class="pln">d</span><span class="pun">;</span><span class="pln"> r</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">n</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">f</span><span class="pun">][</span><span class="pln">r</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m </span><span class="pun">&gt;</span><span class="pln"> maxmoves</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                 </span><span class="com">//with number of moves under limit</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> rans </span><span class="pun">=</span><span class="pln"> max</span><span class="pun">(</span><span class="pln">r</span><span class="pun">,</span><span class="pln"> d</span><span class="pun">-</span><span class="pln">f</span><span class="pun">);</span><span class="pln">                     </span><span class="com">//do not forget the last segment for transmission</span><span class="pln">
    relax</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> rans</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> answer</span><span class="pun">;</span></code></pre>
                                        <p><strong>TheSequencesLevelThree</strong></p>
                                        <p>The key idea for this problem is to sort all elements and then construct
                                            possible sequences by adding elements one-by-one. Since we add elements in
                                            increasing order, each new element can be pushed to the left or to the
                                            right. So each partial solution has x left-most elements and y right-most
                                            elements already set, the remaining middle part of the sequence is not
                                            determined yet. When we add a new element either x or y is increased by one.
                                            Since there is additional constraint on the difference between neighbouring
                                            elements, we have to memorize the border elements. The values of these
                                            elements may be very large, so it is better to store their indices: L is the
                                            index of last pushed element on the left (x-th element from the left) and R
                                            is the index of last pushed element to the right (y-th element from the
                                            right). Look code example for the picture.</p>
                                        <p>Ok, now we have defined state domain (k,x,y,L,R)-&gt;C where k is number of
                                            used elements, x is number of elements to the left, y is number of elements
                                            to the right, L is index of the left border element, R is index of the right
                                            border element, C is number of such partial solutions. Note that L and R are
                                            1-indexed for the reason described further in the text. There are two
                                            conditional transitions: to (k+1,x+1,y,k+1,R) and to (k+1,x,y+1,L,k+1). We
                                            see that DP is layered by parameter k, so we can iterate through all DP
                                            states in order of increasing k. To get the problem answer we have to
                                            consider all states with one undefined element (i.e. k = N-1) and try to put
                                            maximal element to the middle. Also the statement says that there must be at
                                            least one element to the left and one to the right of the "top" number, so
                                            only states with x&gt;=1 and y&gt;=1 are considered for the answer.</p>
                                        <p>It is obvious that this state domain contains a lot of impossible states
                                            because any valid state has x + y = k. From this equation we express y = k —
                                            x explicitly. Now we can throw away all states with other y values. The new
                                            state domain is (k,x,L,R)-&gt;C. It is great that the DP is still layered by
                                            parameter k, so the order of state domain traversal remains simple. Note
                                            that if we exploited k = x + y instead and used state domain (x,y,L,R)-&gt;C
                                            we would have to iterate through all states in order of increasing sum x +
                                            y.</p>
                                        <p>Ok, but do we really need the x and y parameters?! How does the problem
                                            answer depend on them? The only thing that depends on x and y is getting the
                                            problem answer. Not exact x and y values are required but only whether they
                                            are positive or zero. The states with x=2 and x=5 are thus equivalent,
                                            though x=0 and x=1 are not. The information about x and y parameters is
                                            almost unnecessary. To deal with x&gt;=1 and y&gt;=1 conditions we introduce
                                            "null" element in sequence. If parameter L is equal to zero then there is no
                                            element on the left side (as if x = 0). If L is positive then it is index of
                                            sequence element which is on the left border (and of course x&gt;0). Right
                                            side is treated the same way. Now information about x parameter is not
                                            necessary at all. Let's merge equivalent states by deleting parameter x from
                                            the state domain. The state domain is now (k,L,R)-&gt;C.</p>
                                        <p>But there is still room for improvement. Notice that for any valid state
                                            max(L,R) = k. That's because k-th element is the last added element: it must
                                            be the left border element or the right border element. So states with
                                            max(L,R) != k are all impossible (give zero results). We can exploit this
                                            equation. Eliminating parameter k from state domain is not convenient
                                            because then we would have to iterate through states (L,R) in order of
                                            increasing max(L,R). So we would replace parameters L,R to parameters d,m.
                                            These two parameters do not have much sense — they are used only to encode
                                            valid L,R pairs: m==false: L = d, R = k; m==true : L = k, R = d; The final
                                            state domain is (k,d,m), where k is number of set elements, d is index of
                                            element other than k, m means which border element is k. Since DP is
                                            layered, we can use "store two layers" space optimization. The final time
                                            complexity is O(N^2) and space complexity is O(N). Note that such a deep
                                            optimization is overkill because N&lt;=50 in the problem statement. You
                                            could stop at O(N^4) =)</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">// </span><span class="pln">
</span><span class="com">// [a(1), a(2),  ..., a(x-1), arr[L], ?, ?, ..., ?, arr[R], b(y-1), ..., b(2), b(1)]</span><span class="pln">
</span><span class="com">//  \____________known_____________/     unknown    \____________known____________/</span><span class="pln">
</span><span class="com">//            x elements                                       y elements</span><span class="pln">
</span><span class="com">//                          already set elements: k = x + y</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> n</span><span class="pun">;</span><span class="pln">                                                </span><span class="com">//k &amp;mdash; number of elements already set</span><span class="pln">
int64 res</span><span class="pun">[</span><span class="lit">2</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">][</span><span class="lit">2</span><span class="pun">];</span><span class="pln">                                </span><span class="com">//d: arr[d] is last element on one of borders</span><span class="pln">
</span><span class="pun">...</span><span class="pln">                                                   </span><span class="com">//m=0 means arr[d] is last on the left, m=1 &amp;mdash; on the right</span><span class="pln">
n </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">                                   </span><span class="com">//note that actual elements are enumerated from 1</span><span class="pln">
arr</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">                                </span><span class="com">//index d=0 means there is no element on the border yet</span><span class="pln">
sort</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">.</span><span class="kwd">begin</span><span class="pun">(),</span><span class="pln"> arr</span><span class="pun">.</span><span class="kwd">end</span><span class="pun">());</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                                 </span><span class="com">//DP base: no elements, no borders = 1 variant</span><span class="pln">
int64 answer </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">n </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">3</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                              </span><span class="com">//(better to handle this case explicitly)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                       </span><span class="com">//iterate through all states</span><span class="pln">
  memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]));</span><span class="pln">        </span><span class="com">//(do not forget to clear the next layer)</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> d </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> d</span><span class="pun">&lt;=</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> d</span><span class="pun">++)</span><span class="pln">                      </span><span class="com">//(d cannot be greater than k)</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> m </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">&lt;</span><span class="lit">2</span><span class="pun">;</span><span class="pln"> m</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      int64 tres </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">k</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">d</span><span class="pun">][</span><span class="pln">m</span><span class="pun">];</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tres </span><span class="pun">==</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                    </span><span class="com">//discard null states</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> L </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m</span><span class="pun">==</span><span class="lit">0</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> d </span><span class="pun">:</span><span class="pln"> k</span><span class="pun">);</span><span class="pln">                     </span><span class="com">//restore L,R parameters from d,m</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> R </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">m</span><span class="pun">==</span><span class="lit">0</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> k </span><span class="pun">:</span><span class="pln"> d</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> nelem </span><span class="pun">=</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span><span class="pln">                       </span><span class="com">//we'll try to add this element</span><span class="pln">
        
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">L</span><span class="pun">==</span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> abs</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">L</span><span class="pun">]-</span><span class="pln">nelem</span><span class="pun">)&lt;=</span><span class="pln">maxd</span><span class="pun">)</span><span class="pln">        </span><span class="com">//trying to add element to the left border</span><span class="pln">
        </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">R</span><span class="pun">][</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> tres</span><span class="pun">);</span><span class="pln">                
        
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">R</span><span class="pun">==</span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> abs</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">R</span><span class="pun">]-</span><span class="pln">nelem</span><span class="pun">)&lt;=</span><span class="pln">maxd</span><span class="pun">)</span><span class="pln">        </span><span class="com">//trying to add element to the right border</span><span class="pln">
        </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">L</span><span class="pun">][</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> tres</span><span class="pun">);</span><span class="pln">
        
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">==</span><span class="pln"> n</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)</span><span class="pln">                               </span><span class="com">//trying to add highest(last) element to the middle</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">L</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> abs</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">L</span><span class="pun">]-</span><span class="pln">nelem</span><span class="pun">)&lt;=</span><span class="pln">maxd</span><span class="pun">)</span><span class="pln">       </span><span class="com">//ensure that there is a good element to the left</span><span class="pln">
          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">R</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> abs</span><span class="pun">(</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">R</span><span class="pun">]-</span><span class="pln">nelem</span><span class="pun">)&lt;=</span><span class="pln">maxd</span><span class="pun">)</span><span class="pln">     </span><span class="com">//ensure that there is a good element to the right</span><span class="pln">
            </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> tres</span><span class="pun">);</span><span class="pln">                    </span><span class="com">//adding nelem to the middle produces solutions</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span></code></pre>
                                        <p><strong>GameWithGraphAndTree</strong></p>
                                        <p>The solution of this problem was discussed in detail in recipe "Commonly used
                                            DP state domains". Let size(v) be size of v-subtree. The following
                                            constraints hold for any useful transition: 1,2) size(p) = |s|; p in s; 3,4)
                                            size(q) = |t|; q in t; 5) t and s have no common elements; All the other
                                            iterations inside loops are useless because either ires[k][p][s] or
                                            gres[son][q][t] is zero so there is not impact of addition.</p>
                                        <p>The 5-th constraint gives a way to reduce O(4^N) to O(3^N) by applying the
                                            technique described in recipe "Iterating Over All Subsets of a Set". Since t
                                            and s do not intersect, t is subset of complement to s and loop over t can
                                            be taken from that recipe. The time complexity is reduced to O(3^N * N^3).
                                        </p>
                                        <p>The easiest way to exploit constraints 1 and 2 is to check ires[k][p][s] to
                                            be positive immediately inside loops over s. The bad cases for which
                                            constraints are not satisfied are pruned and the lengthy calculations inside
                                            do not happen for impossible states. From this point is it hard to give
                                            precise time complexity. We see that number of possible sets s is equal to
                                            C(n, size(p)) where C is binomial coefficient, and this binomial coefficient
                                            is equal to O(2^n / sqrt(n)) in worst case. So the time complexity is not
                                            worse than O(3^N * N^2.5).</p>
                                        <p>The other optimizations are not important. The cases when q belongs to set s
                                            are pruned. Also there is a check that gres[son][q][t] is positive. The
                                            check is faster than modulo multiplication inside loop over t so let it be.
                                            The loop over t remains the most time-consuming place in code. Ideally this
                                            loop should iterate only over subsets with satisfied constraint 3 — it
                                            should accelerate DP a lot but requires a lot of work, so it's better to
                                            omit it. Here is the optimized piece of code:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">s</span><span class="pun">])</span><span class="pln">                   </span><span class="com">//check that result is not zero &amp;mdash; prune impossible states</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">graph</span><span class="pun">[</span><span class="pln">p</span><span class="pun">][</span><span class="pln">q</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">q</span><span class="pun">))</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                                       </span><span class="com">//prune the case when q belongs to set s</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> oth </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">)-</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">^</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">                                       </span><span class="com">//get complement to set s</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> oth</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="pln">oth</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">gres</span><span class="pun">[</span><span class="pln">son</span><span class="pun">][</span><span class="pln">q</span><span class="pun">][</span><span class="pln">t</span><span class="pun">])</span><span class="pln">      </span><span class="com">//iterate over non-empty subsets of oth</span><span class="pln">
        </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">s</span><span class="pun">^</span><span class="pln">t</span><span class="pun">],</span><span class="pln"> mult</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">s</span><span class="pun">],</span><span class="pln"> gres</span><span class="pun">[</span><span class="pln">son</span><span class="pun">][</span><span class="pln">q</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]));</span><span class="pln"> </span><span class="com">//do calculation only for possible gres states</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span></code></pre>
                                        <p><strong>TourCounting</strong></p>
                                        <p>In this problem we are asked to find number of cycles in graph. I'll present
                                            a long way to solve this problem by DP to show how DP is accelerated by fast
                                            matrix exponentiation. All the cycles have a starting vertex. Let's handle
                                            only cycles that start from vertex 0, the case of all vertices can be solved
                                            by running the solution for each starting vertex separately. For the sake of
                                            simplicity we will count empty cycles too. Since there are exactly n such
                                            cycles, subtract n from the final answer to get rid of empty cycles.</p>
                                        <p>The DP state domain is (i,v)-&gt;C where i is length of tour, v is last
                                            vertex and C is number of ways to get from vertex 0 to vertex v in exactly i
                                            moves. The recurrent equation is the following: C(i+1,v) = sum_u(C(i,u) *
                                            A[u,v]) where A is adjacency matrix. The DP base is: C(0,*) = 0 except
                                            C(0,0) = 1. The answer is clearly sum_i(C(i,0)) for all i=0..k-1. This is DP
                                            solution with time complexity O(k*n). It is too much because we have to run
                                            this solution for each vertex separately.</p>
                                        <p>Let's try to use binary matrix exponentiation to speed this DP up. The DP is
                                            layered, the matrix is just adjacency matrix, but answer depends not only on
                                            the last layer, but on all layers. Such a difficulty appears from time to
                                            time in problems with matrix exponentiation. The workaround is to add some
                                            variables to our vector. Here it is enough to add one variable which is
                                            answer of problem. Let R(i) = sum_j(C(j,0)) for all j=0..i-1. The problem
                                            answer is then R(k), so it no longer depends on intermediate layers results.
                                            Now we have to include it into DP recurrent equations: R(i+1) = R(i) +
                                            C(i,0).</p>
                                        <p>To exploit vector-matrix operations we need to define vector of layer results
                                            and transition matrix. Vector is V(i) = [C(i,0), C(i,1), C(i,2), ...,
                                            C(n-1,0); R(i)]. Matrix TM is divided into four parts: upperleft (n x n)
                                            part is precisely the adjacency matrix A, upperright n-column is zero,
                                            bottomright element is equal to one, bottomleft n-row is filled with zeros
                                            except for first element which is equal to one. It is transition matrix
                                            because V(i+1) = V(i) * TM. Better check on the piece of paper that the
                                            result of vector-matrix multiplication precisely matches the recurrent
                                            equations of DP. The answer is last (n-th) element of vector V(k) = V(0) *
                                            TM^k. DP base vector V(0) is (1, 0, 0, ..., 0; 0). If power of matrix is
                                            calculated via fast exponentiation, the time complexity is O(n^3 * log(k)).
                                            Even if you run this DP solution for each vertex separately the solution
                                            will be fast enough to be accepted.</p>
                                        <p>But there are redundant operations in such a solution. Notice that the core
                                            part of transition matrix is adjacency matrix. It remains the same for each
                                            of DP run. To eliminate this redundancy all the DP runs should be merged
                                            into one run. The slowest part of DP run is getting power of transition
                                            matrix. Let's merge all transition matrices. The merged matrix is (2*n x
                                            2*n) in size, upperleft (n x n) block is adjacency matrix, upperright block
                                            is filled with zeros, bottomright and bottomleft blocks are identity
                                            matrices. This matrix contains all previously used transition matrices as
                                            submatrices. Therefore the k-th power of this matrix also contains k-th
                                            powers of all used transition matrices TM. Now we can get answer of each DP
                                            by multiplying the vector corresponding to DP base and getting correct
                                            element of result. The time complexity for the whole problem is O(n^3 *
                                            log(k)).</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="kwd">struct</span><span class="pln"> </span><span class="typ">Matrix</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                                     </span><span class="com">//class of (2n x 2n) matrix</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> arr</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">*</span><span class="lit">2</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">*</span><span class="lit">2</span><span class="pun">];</span><span class="pln">
</span><span class="pun">};</span><span class="pln">
</span><span class="typ">Matrix</span><span class="pln"> </span><span class="typ">Multiply</span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">Matrix</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">a</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">Matrix</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">b</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"> </span><span class="com">//get product of two matrices</span><span class="pln">
</span><span class="typ">Matrix</span><span class="pln"> res</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> tres </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln">
    </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">tres</span><span class="pun">,</span><span class="pln"> mult</span><span class="pun">(</span><span class="pln">a</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">u</span><span class="pun">],</span><span class="pln"> b</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">u</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]));</span><span class="pln">
  res</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> tres</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> res</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
</span><span class="typ">Matrix</span><span class="pln"> matr</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">;</span><span class="pln">                               </span><span class="com">//matr is the constructed matrix</span><span class="pln">
n </span><span class="pun">=</span><span class="pln"> g</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">                                   </span><span class="com">//res will be its power</span><span class="pln">
s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">2</span><span class="pun">*</span><span class="pln">n</span><span class="pun">;</span><span class="pln">                                        </span><span class="com">//s is size of matrix</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                   </span><span class="com">//fill the matrix elements:</span><span class="pln">
    matr</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">g</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'Y'</span><span class="pun">);</span><span class="pln">          </span><span class="com">//upperleft = adjacency matrix</span><span class="pln">
    matr</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="pln">n</span><span class="pun">][</span><span class="pln">j</span><span class="pun">+</span><span class="pln">n</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">==</span><span class="pln">j</span><span class="pun">);</span><span class="pln">                </span><span class="com">//bottomright = identity matrix</span><span class="pln">
    matr</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="pln">n</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">==</span><span class="pln">j</span><span class="pun">);</span><span class="pln">                  </span><span class="com">//borromleft = identity matrix</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">                       </span><span class="com">//set res matrix to identity</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;</span><span class="pln">s</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln">
    res</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">==</span><span class="pln">j</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> k</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&gt;&gt;=</span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                   </span><span class="com">//perform binary exponentiation</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> res </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Multiply</span><span class="pun">(</span><span class="pln">res</span><span class="pun">,</span><span class="pln"> matr</span><span class="pun">);</span><span class="pln">         </span><span class="com">//is current bit of power is set, multiply result by matr</span><span class="pln">
  matr </span><span class="pun">=</span><span class="pln"> </span><span class="typ">Multiply</span><span class="pun">(</span><span class="pln">matr</span><span class="pun">,</span><span class="pln"> matr</span><span class="pun">);</span><span class="pln">                  </span><span class="com">//matr represents (2^b)-th power of original matrix</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="pun">((-</span><span class="pln">n</span><span class="pun">)%</span><span class="pln">m </span><span class="pun">+</span><span class="pln"> m</span><span class="pun">)</span><span class="pln"> </span><span class="pun">%</span><span class="pln"> m</span><span class="pun">;</span><span class="pln">                  </span><span class="com">//subtract n empty cycles from problem answer</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">                       </span><span class="com">//sum results of individual DP runs</span><span class="pln">
  </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">.</span><span class="pln">arr</span><span class="pun">[</span><span class="pln">n</span><span class="pun">+</span><span class="pln">i</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]);</span><span class="pln">                 </span><span class="com">//get (n+i)-th element of V(0) * (matr ^ k)</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> answer</span><span class="pun">;</span><span class="pln">                                  </span><span class="com">//where V(0) has only i-th non-zero element set to 1</span></code></pre>
                                        <p><strong>RoadOrFlightHard</strong></p>
                                        <p>In this problem we are asked to find minimal distance between two points in a
                                            special graph (with line structure). Just like in Dijkstra algorithm, state
                                            domain should include v parameter — city number and the result of state is
                                            minimal distance from starting city (0) to current city (v). Also there is
                                            constraint on number of takeoffs, so we have to memorize that number as
                                            parameter t. After these obvious thoughts we have the state domain
                                            (v,t)-&gt;D, where v=0..n and t=0..k. Unlike previous examples, this DP
                                            solution follows backwards(recurrent) style, so each result is determined
                                            using the previous results. The transition rules are rather simple. If king
                                            comes from previous city by ground, then D(v,t) = D(v-1,t) + R[v-1] where R
                                            is array of road travelling times. If king arrives to current city by plane
                                            from city u (u &lt; V), then D(v,t) = D(u,t-1) + (F[u] + F[u+1] + F[u+2] +
                                            ... + F[v-2] + F[v-1]). Since any of such conditions may happen, the result
                                            of minimum of results for road and flight cases for all possible departure
                                            cities. The problem answer is min(D(n,t)) for t=0..k.</p>
                                        <p>Unfortunately, this DP has O(N^3 * K) time complexity. For each possible
                                            flight the sum of array elements in a segment is calculated and this
                                            calculation results in the innermost loop. To eliminate this loop we have to
                                            precalculate prefix sums for flight times. Let S(v) = F(0) + F(1) + F(2) +
                                            ... + F(v-1) for any v=0..n. This array is called prefix sums array of F and
                                            it can be computed in linear time by obvious DP which originates from these
                                            recurrent equations: S(0) = 0; S(v+1) = S(v) + F(v). Having prefix sums
                                            array, sum of elements of any segment can be calculated in O(1) time because
                                            F(L) + ... + F(R-1) = S(R) — S(L). So the recurrent relations for flight
                                            case are rewritten as: D(v,t) = D(u,t-1) + (S(v) — S(u)). The time
                                            complexity is now O(N^2 * K).</p>
                                        <p>The next optimization is not that easy. The best result in case king arrives
                                            to city v by some plane is D(v,t) = min_u(D(u,t-1) + S(v) — S(u)) where u
                                            takes values from 0 to v-1. Transform the equation: D(v,t) = min_u(D(u,t-1)
                                            — S(u) + S(v)) = min_u(D(u,t-1) — S(u)) + S(v). Notice that the expression
                                            inside the minimum does not depend on v anymore. Let's denote the whole
                                            minimum as A(v-1,t-1). The A array is added to state domain and its contents
                                            can be calculated during the DP. It is interesting to discuss the meaning of
                                            A(v,t). I would say it is the best virtual flight distance from city 0 to
                                            city v. It is virtual because the flight can start at any city. Here are the
                                            full and final transitions: D(v,t) = min(D(v-1,t) + R[v-1], A(v-1,t-1) +
                                            S(v)); A(v,t) = min(A(v-1,t), D(v,t) — S(v));</p>
                                        <p>Now the solution works in O(N * K) time. But the size of results arrays
                                            exceed memory limit. The workaround is very simple. Notice that the final DP
                                            is layered by v parameter because to get results (v,t) only (v-1,*) and
                                            (v,*) states are required. So we can store results only for two adjacent
                                            layers at any time. After this optimization space complexity becomes linear
                                            O(N + K).</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">int64 sum</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">];</span><span class="pln">                                              </span><span class="com">//prefix sums array S</span><span class="pln">
int64 vfd</span><span class="pun">[</span><span class="lit">2</span><span class="pun">][</span><span class="pln">MAXK</span><span class="pun">];</span><span class="pln">                                           </span><span class="com">//A(v,t) &amp;mdash; virtual flight distance</span><span class="pln">
int64 res</span><span class="pun">[</span><span class="lit">2</span><span class="pun">][</span><span class="pln">MAXK</span><span class="pun">];</span><span class="pln">                                           </span><span class="com">//D(v,t) &amp;mdash; minimal distance to city v with t takeoffs</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
sum</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln"> sum</span><span class="pun">[</span><span class="pln">v</span><span class="pun">+</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> sum</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> flight</span><span class="pun">[</span><span class="pln">v</span><span class="pun">];</span><span class="pln">    </span><span class="com">//prefix sums calculation</span><span class="pln">

memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">));</span><span class="pln">                               </span><span class="com">//DP base for city 0:</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">vfd</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">vfd</span><span class="pun">));</span><span class="pln">                               </span><span class="com">//only zero takeoffs with zero distance</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                                              </span><span class="com">//all other entries are infinities</span><span class="pln">
vfd</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;=</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln">                                  </span><span class="com">//iterate through all states with v&gt;0</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">&lt;=</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                              
  res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[(</span><span class="pln">v</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> road</span><span class="pun">[</span><span class="pln">v</span><span class="pun">-</span><span class="lit">1</span><span class="pun">];</span><span class="pln">              </span><span class="com">//try road way to here</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">t </span><span class="pun">&gt;</span><span class="pln"> </span><span class="lit">0</span><span class="pun">)</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">],</span><span class="pln"> vfd</span><span class="pun">[(</span><span class="pln">v</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">-</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> sum</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]);</span><span class="pln"> </span><span class="com">//try flight arrival here</span><span class="pln">
  vfd</span><span class="pun">[</span><span class="pln">v</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">vfd</span><span class="pun">[(</span><span class="pln">v</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">mdash</span><span class="pun">;</span><span class="pln"> sum</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]);</span><span class="pln"> </span><span class="com">//try flight departure here</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
int64 answer </span><span class="pun">=</span><span class="pln"> INF</span><span class="pun">;</span><span class="pln">                                         </span><span class="com">//find minimal distance to city n</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">&lt;=</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">++)</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">n</span><span class="pun">&amp;</span><span class="lit">1</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]);</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> answer</span><span class="pun">;</span></code></pre>
                                        <p><strong>Problem:</strong> The most creative part of inventing dynamic
                                            programming solution is defining recurrent relations. The recurrent
                                            relations consist of two parts: state domain and transitions. State domain
                                            is a set of states (subproblems) in dynamic programming. For each state the
                                            subresult will be calculated eventually. Transitions are the relations
                                            between different states which help calculate the subresults.</p>
                                        <p>This recipe covers frequently used state domain types. The general approaches
                                            of dealing with them and real SRM examples are given. Also few optimizations
                                            specific to particular domains are mentioned here.</p>
                                        <p><strong>Solution</strong> Code of DP solution usually contains an array
                                            representing subresults on the state domain. For example, classic knapsack
                                            problem solution will be like:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">int</span><span class="pln"> maxcost</span><span class="pun">[</span><span class="pln">items</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">space</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">maxcost</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">maxcost</span><span class="pun">));</span><span class="pln">   </span><span class="com">//fill with negative infinity</span><span class="pln">
maxcost</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                       </span><span class="com">//base of DP</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">items</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">            </span><span class="com">//iterations over states in proper order</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;=</span><span class="pln">space</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> mc </span><span class="pun">=</span><span class="pln"> maxcost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">              </span><span class="com">//we handle two types forward transitions</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> ni</span><span class="pun">,</span><span class="pln"> nj</span><span class="pun">,</span><span class="pln"> nmc</span><span class="pun">;</span><span class="pln">                     </span><span class="com">//from state (i,j)-&gt;mc to state (ni,nj)-&gt;nmc</span><span class="pln">

  ni </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//forward transition: do not add i-th item</span><span class="pln">
  nj </span><span class="pun">=</span><span class="pln"> j</span><span class="pun">;</span><span class="pln">
  nmc </span><span class="pun">=</span><span class="pln"> mc</span><span class="pun">;</span><span class="pln">      
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">maxcost</span><span class="pun">[</span><span class="pln">ni</span><span class="pun">][</span><span class="pln">nj</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> nmc</span><span class="pun">)</span><span class="pln">           </span><span class="com">//relaxing result for new state</span><span class="pln">
    maxcost</span><span class="pun">[</span><span class="pln">ni</span><span class="pun">][</span><span class="pln">nj</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nmc</span><span class="pun">;</span><span class="pln">

  ni </span><span class="pun">=</span><span class="pln"> i </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//forward transition: add i-th item</span><span class="pln">
  nj </span><span class="pun">=</span><span class="pln"> j </span><span class="pun">+</span><span class="pln"> size</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
  nmc </span><span class="pun">=</span><span class="pln"> mc </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">nj </span><span class="pun">&lt;=</span><span class="pln"> space </span><span class="pun">&amp;&amp;</span><span class="pln"> maxcost</span><span class="pun">[</span><span class="pln">ni</span><span class="pun">][</span><span class="pln">nj</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> nmc</span><span class="pun">)</span><span class="pln">
    maxcost</span><span class="pun">[</span><span class="pln">ni</span><span class="pun">][</span><span class="pln">nj</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nmc</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln">                </span><span class="com">//getting answer from state results</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;=</span><span class="pln">space</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">maxcost</span><span class="pun">[</span><span class="pln">items</span><span class="pun">][</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> answer</span><span class="pun">)</span><span class="pln">
  answer </span><span class="pun">=</span><span class="pln"> maxcost</span><span class="pun">[</span><span class="pln">items</span><span class="pun">][</span><span class="pln">j</span><span class="pun">];</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> answer</span><span class="pun">;</span></code></pre>
                                        <p>Here (i,j) is state of DP with result equal to maxcost[i][j]. The result here
                                            means the maximal cost of items we can get by taking some of first i items
                                            with overall size of exactly j. So the set of (i,j) pairs and concept of
                                            maxcost[i][j] here comprise a state domain. The forward transition is adding
                                            or not adding the i-th item to the set of items we have already chosen.</p>
                                        <p>The order of iterations through all DP states is important. The code above
                                            iterates through states with pairs (i,j) sorted lexicographically. It is
                                            correct since any transition goes from set (i,*) to set (i+1,*), so we see
                                            that i is increasing by one. Speaking in backward (recurrent) style, the
                                            result for each state (i,j) directly depends only on the results for the
                                            states (i-1,*).</p>
                                        <p>To determine order or iteration through states we have to define order on
                                            state domain. We say that state (i1,j1) is greater than state (i2,j2) if
                                            (i1,j1) directly or indirectly (i.e. through several other states) depends
                                            on (i2,j2). This is definition of order on the state domain used. In DP
                                            solution any state must be considered after all the lesser states. Else the
                                            solution would give incorrect result.</p>
                                        <p><strong>Multidimensional array</strong> The knapsack DP solution described
                                            above is an example of multidimensional array state domain (with 2
                                            dimensions). A lot of other problems have similar state domains. Generally
                                            speaking, in this category states are represented by k parameters: (i1, i2,
                                            i3, ..., ik). So in the code we define a multidimensional array for state
                                            results like: int Result[N1][N2][N3]...[Nk]. Of course there are some
                                            transition rules (recurrent relations). These rules themselves can be
                                            complex, but the order of states is usually simple.</p>
                                        <p>In most cases the states can be iterated through in lexicographical order. To
                                            do this you have to ensure that if I = (i1, i2, i3, ..., ik) directly
                                            depends on J = (j1, j2, j3, ..., jk) then I is lexicographically greater
                                            that J. This can be achieved by permuting parameters (like using (j,i)
                                            instead of (i,j)) or reversing them. But it is usually easier to change the
                                            order and direction of nested loops. Here is general code of lexicographical
                                            traversion:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i1 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i1</span><span class="pun">&lt;</span><span class="pln">N1</span><span class="pun">;</span><span class="pln"> i1</span><span class="pun">++)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i2 </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i2</span><span class="pun">&lt;</span><span class="pln">N1</span><span class="pun">;</span><span class="pln"> i2</span><span class="pun">++)</span><span class="pln">
  </span><span class="pun">...</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> ik </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> ik</span><span class="pun">&lt;</span><span class="typ">Nk</span><span class="pun">;</span><span class="pln"> ik</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
      </span><span class="com">//get some states (j1, j2, j3, ..., jk) -&gt; jres by performing transitions</span><span class="pln">
      </span><span class="com">//and handle them</span><span class="pln">
    </span><span class="pun">}</span></code></pre>
                                        <p>Note: changing order of DP parameters in array and order of nested loops can
                                            noticably affect performance on modern computers due to CPU cache behavior.
                                        </p>
                                        <p>This type of state domain is the easiest to understand and implement, that's
                                            why most DP tutorials show problems of this type. But it is not the most
                                            frequently used type of state domain in SRMs. DP over subsets is much more
                                            popular.</p>
                                        <p><strong>Subsets of a given set</strong></p>
                                        <p>The problems of this type has some set X. The number of elements in this set
                                            is small: less than 20. The idea of DP solution is to consider all subsets
                                            of X as state domain. Often there are additional parameters. So generally we
                                            have state domain in form (s,a) where s is a subset of X and "a" represents
                                            additional parameters.</p>
                                        <p>Consider TSP problem as an example. The set of cities X={0, 1, 2, ..., N-1}
                                            is used here. State domain will have two parameters: s and a. The state
                                            (s,a)-&gt;R means that R is the shortest path from city 0 to city "a" which
                                            goes through all the vertices from subset s exactly once. The transition is
                                            simply adding one city v to the end of path: (s,a)-&gt;R turns into
                                            (s+{v},v)-&gt;R + M[a,v]. Here M[i,j] is distance between i-th and j-th
                                            city. Any hamiltonian cycle is a path which goes through each vertex exactly
                                            once plus the edge which closes the cycle, so the answer for TSP problem can
                                            be computed as min(R[X,a]+M[a,0]) among all vertices "a".</p>
                                        <p>It is very convenient to encode subsets with binary numbers. Look recipe
                                            "Representing sets with bitfields" for detailed explanation.</p>
                                        <p>The state domain of DP over subsets is usually ordered by set inclusion. Each
                                            forward transition adds some elements to the current subset, but does not
                                            subtract any. So result for each state (s,a) depends only on the results of
                                            states (t,b) where t is subset of s. If state domain is ordered like this,
                                            then we can iterate through subsets in lexicographical order of binary
                                            masks. Since subsets are usually represented with binary integers, we can
                                            iterate through all subsets by iterating through all integers from 0 to 2^N
                                            — 1. For example in TSP problem solution looks like:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">int</span><span class="pln"> res</span><span class="pun">[</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">N</span><span class="pun">][</span><span class="pln">N</span><span class="pun">];</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">));</span><span class="pln">       </span><span class="com">//filling results with positive infinity</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                   </span><span class="com">//DP base</span><span class="pln">

</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s </span><span class="pun">&lt;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">N</span><span class="pun">);</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln">    </span><span class="com">//iterating through all subsets in lexicographical order</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a </span><span class="pun">&lt;</span><span class="pln"> N</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> r </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="pln">a</span><span class="pun">];</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v </span><span class="pun">&lt;</span><span class="pln"> N</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">   </span><span class="com">//looking through all transitions (cities to visit next)</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">v</span><span class="pun">))</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">     </span><span class="com">//we cannot visit cities that are already visited</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> ns </span><span class="pun">=</span><span class="pln"> s </span><span class="pun">|</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">v</span><span class="pun">);</span><span class="pln">          </span><span class="com">//perform transition</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> na </span><span class="pun">=</span><span class="pln"> v</span><span class="pun">;</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> nr </span><span class="pun">=</span><span class="pln"> r </span><span class="pun">+</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">a</span><span class="pun">][</span><span class="pln">v</span><span class="pun">];</span><span class="pln">      </span><span class="com">//by adding edge (a &amp;mdash; v) distance</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">ns</span><span class="pun">][</span><span class="pln">na</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> nr</span><span class="pun">)</span><span class="pln">         </span><span class="com">//relax result for state (ns,na) with nr</span><span class="pln">
      res</span><span class="pun">[</span><span class="pln">ns</span><span class="pun">][</span><span class="pln">na</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nr</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln">            </span><span class="com">//get TSP answer</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a </span><span class="pun">&lt;</span><span class="pln"> N</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln">
answer </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">[(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">N</span><span class="pun">)-</span><span class="lit">1</span><span class="pun">][</span><span class="pln">a</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">a</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]);</span></code></pre>
                                        <p>Often in DP over subsets you have to iterate through all subsets or supersets
                                            of a given set s. The bruteforce implementation will require O(4^N) time for
                                            the whole DP, but it can be easily optimized to take O(3^N). Please read
                                            recipe "Iterating Over All Subsets of a Set".</p>
                                        <p><strong>Substrings of a given string</strong></p>
                                        <p>There is a fixed string or a fixed segment. According to the problem
                                            definition, it can be broken into two pieces, then each of pieces can be
                                            again divided into two pieces and so forth until we get unit-length strings.
                                            And by doing this we need to achieve some goal.</p>
                                        <p>Classical example of DP over substrings is context-free grammar parsing
                                            algorithm. Problems which involve putting parentheses to arithmetic
                                            expression and problems that ask to optimize the overall cost of recursive
                                            breaking are often solved by DP over substrings. In this case there are two
                                            special parameters L and R which represent indices of left and right borders
                                            of a given substring. There can be some additional parameters, we denote
                                            them as "a". So each state is defined by (L,R,a). To calculate answer for
                                            each state, all the ways to divide substring into two pieces are considered.
                                            Because of it, states must be iterated through in order or non-decreasing
                                            length. Here is the scheme of DP over substrings (without additional
                                            parameters):</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  res</span><span class="pun">[</span><span class="pln">N</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">N</span><span class="pun">+</span><span class="lit">1</span><span class="pun">];</span><span class="pln">                          </span><span class="com">//first: L, second: R</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">&lt;=</span><span class="pln">N</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln">              </span><span class="com">//iterate size(length) of substring</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> L </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> L</span><span class="pun">+</span><span class="pln">s</span><span class="pun">&lt;=</span><span class="pln">N</span><span class="pun">;</span><span class="pln"> L</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">        </span><span class="com">//iterate left border index</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> R </span><span class="pun">=</span><span class="pln"> L </span><span class="pun">+</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">                      </span><span class="com">//right border index is clear</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&lt;=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                       
    res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPBase</span><span class="pun">(</span><span class="pln">L</span><span class="pun">,</span><span class="pln"> R</span><span class="pun">);</span><span class="pln">         </span><span class="com">//base of DP &amp;mdash; no division</span><span class="pln">
    </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  tres </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???;</span><span class="pln">                          
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> M </span><span class="pun">=</span><span class="pln"> L</span><span class="pun">+</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> M</span><span class="pun">&lt;=</span><span class="pln">R</span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln"> M</span><span class="pun">++)</span><span class="pln">      </span><span class="com">//iterate through all divisions</span><span class="pln">
    tres </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPInduction</span><span class="pun">(</span><span class="pln">tres</span><span class="pun">,</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">M</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">M</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]);</span><span class="pln">
  res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> tres</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
answer </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPAnswer</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">N</span><span class="pun">]);</span></code></pre>
                                        <p><strong>Subtrees(vertices) of a given rooted tree</strong></p>
                                        <p>The problem involves a rooted tree. Sometimes a graph is given and its DFS
                                            search tree is used. Some sort of result can be calculated for each subtree.
                                            Since each subtree is uniquely identified by its root, we can treat DP over
                                            subtrees as DP over vertices. The result for each non-leaf vertex is
                                            determined by the results of its immediate children.</p>
                                        <p>The DP over subtree has a state domain in form (v,a) where v is a root of
                                            subtree and "a" may be some additional parameters. states are ordered
                                            naturally be tree order on vertices. Therefore the easiest way to iterate
                                            through states in correct order is to launch DFS from the root of tree. When
                                            DFS exits from a vertex, its result must be finally computed and stored in
                                            global memory. The code generally looks like:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">bool</span><span class="pln"> vis</span><span class="pun">[</span><span class="pln">N</span><span class="pun">];</span><span class="pln">                                  </span><span class="com">//visited mark for DFS</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">N</span><span class="pun">];</span><span class="pln">                                       </span><span class="com">//DP result array</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> DFS</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                             </span><span class="com">//visit v-rooted subtree recursively</span><span class="pln">
vis</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">                              </span><span class="com">//mark vertex as visited</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">???;</span><span class="pln">                               </span><span class="com">//initial result, which is final result in case v is leaf</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">nbr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">].</span><span class="pln">size</span><span class="pun">();</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">     </span><span class="com">//iterate through all sons s</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> nbr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">i</span><span class="pun">];</span><span class="pln">                        
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">s</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                            </span><span class="com">//if vertex is not visited yet, then it's a son in DFS tree</span><span class="pln">
    DFS</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">                                 </span><span class="com">//visit it recursively</span><span class="pln">
    res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPInduction</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">]);</span><span class="pln">   </span><span class="com">//recalculate result for current vertex</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">vis</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">vis</span><span class="pun">));</span><span class="pln">              </span><span class="com">//mark all vertices as not visited</span><span class="pln">
DFS</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">                                       </span><span class="com">//run DFS from the root = vertex 0</span><span class="pln">
answer </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPAnswer</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">                    </span><span class="com">//get problem answer from result of root</span></code></pre>
                                        <p>Sometimes the graph of problem is not connected (e.g. a forest). In this case
                                            run a series of DFS over the whole graph. The results for roots of
                                            individual trees are then combined in some way. Usually simple
                                            summation/maximum or a simple formula is enough but in tough cases this
                                            "merging problem" can turn out to require another DP solution.</p>
                                        <p>The DPInduction is very simple in case when there are no additional
                                            parameters. But very often state domain includes the additional parameters
                                            and becomes complicated. DPInduction turns out to be another(internal) DP in
                                            this case. Its state domain is (k,a) where k is number of sons of vertex
                                            considered so far and "a" is additional info. Be careful about the storage
                                            of results of this internal DP. If you are solving optimization problem and
                                            you are required to recover the solution (not only answer) then you have to
                                            save results of this DP for solution recovering. In this case you'll have an
                                            array globalres[v,a] and an array internalres[v,k,a]. Topcoder problems
                                            rarely require solution, so storage of internal DP results is not necessary.
                                            It is easier not to store them globally. In the code below internal results
                                            for a vertex are initialized after all the sons are traversed recursively
                                            and are discarded after DFS exits a vertex. This case is represented in the
                                            code below:</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">bool</span><span class="pln"> vis</span><span class="pun">[</span><span class="pln">N</span><span class="pun">];</span><span class="pln">
gres</span><span class="pun">[</span><span class="pln">N</span><span class="pun">][</span><span class="pln">A</span><span class="pun">];</span><span class="pln">
intres</span><span class="pun">[</span><span class="pln">N</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">A</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> DFS</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
vis</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">

vector</span><span class="str">&lt;int&gt;</span><span class="pln"> sons</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">nbr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">].</span><span class="pln">size</span><span class="pun">();</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">    </span><span class="com">//first pass: visit all sons and store their indices</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> nbr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">i</span><span class="pun">];</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">s</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
    DFS</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">
    sons</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">s</span><span class="pun">);</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> SK </span><span class="pun">=</span><span class="pln"> sons</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">                      </span><span class="com">//clear the internal results array</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;=</span><span class="pln">SK</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln">
  memset</span><span class="pun">(</span><span class="pln">intres</span><span class="pun">[</span><span class="pln">k</span><span class="pun">],</span><span class="pln"> </span><span class="pun">?,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">intres</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]));</span><span class="pln">

</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">&lt;</span><span class="pln">A</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln">                  </span><span class="com">//second pass: run internal DP over array of sons</span><span class="pln">
  intres</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">a</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">InternalDPBase</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;</span><span class="pln">SK</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln">                 </span><span class="com">//k = number of sons considered so far</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">&lt;</span><span class="pln">A</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln">                </span><span class="com">//a = additional parameter for them</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> b</span><span class="pun">&lt;</span><span class="pln">A</span><span class="pun">;</span><span class="pln"> b</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">            </span><span class="com">//b = additional parameter for the son being added</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> na </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPTransition</span><span class="pun">(</span><span class="pln">v</span><span class="pun">,</span><span class="pln"> a</span><span class="pun">,</span><span class="pln"> b</span><span class="pun">);</span><span class="pln">
      </span><span class="kwd">int</span><span class="pln"> nres </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPInduction</span><span class="pun">(</span><span class="pln">intres</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">a</span><span class="pun">],</span><span class="pln"> gres</span><span class="pun">[</span><span class="pln">sons</span><span class="pun">[</span><span class="pln">k</span><span class="pun">]][</span><span class="pln">b</span><span class="pun">]);</span><span class="pln">
      intres</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">na</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="typ">DPMerge</span><span class="pun">(</span><span class="pln">intres</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">na</span><span class="pun">],</span><span class="pln"> nres</span><span class="pun">);</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">&lt;</span><span class="pln">A</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln">                  </span><span class="com">//copy answer of internal DP to result for vertex</span><span class="pln">
  gres</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">a</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> intres</span><span class="pun">[</span><span class="pln">SK</span><span class="pun">][</span><span class="pln">a</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">vis</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">vis</span><span class="pun">));</span><span class="pln">              </span><span class="com">//series of DFS</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;</span><span class="pln">N</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">v</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
DFS</span><span class="pun">(</span><span class="pln">v</span><span class="pun">);</span><span class="pln">
</span><span class="pun">???</span><span class="pln">                                         </span><span class="com">//handle results for connected component</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">???</span><span class="pln">                                           </span><span class="com">//get the answer in some way</span></code></pre>
                                        <p>It is very important to understand how time/space complexity is calculated
                                            for DP over subtrees. For example, the code just above requires O(N*A^2)
                                            time. Though dumb analysis says it is O(N^2*A^2): {N vertices} x {SK&lt;=N
                                            sons for each} x A x A. Let Ki denote number of sons of vertex i. Though
                                            each Ki may be as large as N-1, their sum is always equal to N-1 in a rooted
                                            tree. This fact is the key to further analysis. Suppose that DFS code for
                                            i-th vertex runs in not more than Ki*t time. Since DFS is applied only once
                                            to each vertex, the overall time will be TC(N) = sum(Ki*t) &lt;= N*t.
                                            Consider t=A^2 for the case above and you'll get O(N*A^2) time complexity.
                                            To benefit from this acceleration, be sure not to iterate through all
                                            vertices of graph in DFS. For example above, running memset for the whole
                                            intres array in DFS will raise the time complexity. Time of individual DFS
                                            run will become O(N*A + Ki*A^2) instead of O(Ki*A^2). The overall time
                                            complexity will become O(N^2*A + N*A^2) which is great regress in case if A
                                            is much smaller that N. Using the same approach you may achieve O(N*A) space
                                            complexity in case you are asked to recover solution. We have already said
                                            that to recover solution you have to store globally the array
                                            internalres[v,k,a]. If you allocate memory for this array dynamically, then
                                            you can ignore completely states with k&gt;Ki. Since the sum of all Ki is N,
                                            you will get O(N*A) space.</p>
                                        <p><strong>Layer count + layer profile</strong></p>
                                        <p>This is the toughest type of DP state domain. It is usually used in tiling or
                                            covering problems on special graphs. The classic examples are: calculate
                                            number of ways to tile the rectangular board with dominoes (certain cells
                                            cannot be used); or put as many chess figures on the chessboard as you can
                                            so that they do not hit each other (again, some cells may be restricted).
                                        </p>
                                        <p>Generally speaking, all these problems can be solved with DP over subsets
                                            (use set of all cells of board). DP with profiles is an optimization which
                                            exploits special structure in this set. The board we have to cover/tile is
                                            represented as an array of layers. We try to consider layers one by one and
                                            store partial solutions after each layer. In simple rectangular board case
                                            layer is one row of the board. The profile is a subset of cells in current
                                            row which are already tiled.</p>
                                        <p>The state domain has form (k,p) where k is number of fully processed layers
                                            and p is so-called profile of solution. Profile is the necessary information
                                            about solution in layers that are not fully processed yet. The transitions
                                            go from (k,p) to (k+1,q) where q is some new profile. The number of
                                            transitions for each state is usually large, so they all are iterated
                                            through by recursive search, sometimes with pruning. The search has to find
                                            all the ways to increase the partial solution up to the next layer.</p>
                                        <p>The example code below calculates the number of way to fully cover empty
                                            cells on the given rectangular board with dominoes.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">M</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">N</span><span class="pun">];</span><span class="pln">                     
                                    </span><span class="com">//k = number of fully tiled rows               </span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> k</span><span class="pun">,</span><span class="pln"> p</span><span class="pun">,</span><span class="pln"> q</span><span class="pun">;</span><span class="pln">                            </span><span class="com">//p = profile of k-th row = subset of tiled cells</span><span class="pln">
</span><span class="kwd">bool</span><span class="pln"> </span><span class="kwd">get</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                       </span><span class="com">//q = profile of the next row (in search)        </span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'#'</span><span class="pln">              
  </span><span class="pun">||</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">&amp;</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">i</span><span class="pun">));</span><span class="pln">                  </span><span class="com">//check whether i-th cell in current row is not free</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">void</span><span class="pln"> </span><span class="typ">Search</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                    </span><span class="com">//i = number of processed cells in current row</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">==</span><span class="pln"> N</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="kwd">add</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">q</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">p</span><span class="pun">]);</span><span class="pln">        </span><span class="com">//the current row processed, make transition</span><span class="pln">
</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">i</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                         </span><span class="com">//if current cell is not free, skip it</span><span class="pln">
</span><span class="typ">Search</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">return</span><span class="pun">;</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">&lt;</span><span class="pln">N </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="kwd">get</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">))</span><span class="pln">               </span><span class="com">//try putting (k,i)-(k,i+1) domino</span><span class="pln">
</span><span class="typ">Search</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">2</span><span class="pun">);</span><span class="pln">

</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">&lt;</span><span class="pln">M </span><span class="pun">&amp;&amp;</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">!=</span><span class="pln"> </span><span class="str">'#'</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">   </span><span class="com">//try putting (k,i)-(k+1,i) domino</span><span class="pln">
q </span><span class="pun">^=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">i</span><span class="pun">);</span><span class="pln">                        </span><span class="com">//note that the profile of next row is changed</span><span class="pln">
</span><span class="typ">Search</span><span class="pun">(</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">);</span><span class="pln">
q </span><span class="pun">^=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">i</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//base of DP</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;</span><span class="pln">M</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln">                   </span><span class="com">//iterate over number of processed layers</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">N</span><span class="pun">);</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">          </span><span class="com">//iterate over profiles</span><span class="pln">
q </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                              </span><span class="com">//initialize the new profile</span><span class="pln">
</span><span class="typ">Search</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">                          </span><span class="com">//start the search for all transitions</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">M</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">                 </span><span class="com">//all rows covered with empty profile = answer</span></code></pre>
                                        <p>The asymptotic time complexity is not easy to calculate exactly. Since search
                                            for i performs one call to i+1 and one call to i+2, the complexity of
                                            individual search is not more than N-th Fibonacci number = fib(N). Moreover,
                                            if profile p has only F free cells it will require O(fib(F)) time due to
                                            pruning. If we sum C(N,F)fib(F) for all F we'll get something like
                                            (1+phi)^N, where phi is golden ratio. The overall time complexity is O(M *
                                            (1+phi)^N). Empirically it is even lower.</p>
                                        <p>The code is not optimal. Almost all DP over profiles should use "storing two
                                            layers" space optimization. Look "Optimizing DP solution" recipe. Moreover
                                            DP over broken profiles can be used. In this DP state domain (k,p,i) is
                                            used, where i is number of processed cells in a row. No recursive search is
                                            launched since it is converted to the part of DP. The time complexity is
                                            even lower with this solution.</p>
                                        <p>The hard DP over profiles examples can include extensions like: 1. Profile
                                            consists of more than one layer. For example to cover the grid with
                                            three-length tiles you need to store two layers in the profile. 2. Profile
                                            has complex structure. For example to find optimal in some sense hamiltonian
                                            cycle on the rectangular board you have to use matched parentheses strings
                                            as profiles. 3. Distinct profile structure. Set of profiles may be different
                                            for each layer. You can store profiles in map in this case.</p>
                                        <p><strong>Examples:</strong></p>
                                        <p><strong>InformFriends</strong></p>
                                        <p>We are asked to find assignment man-&gt;fact which maximizes the number of
                                            facts with constraint that everyone must know all the facts. In the optimal
                                            assignment people can be divided into fact-groups. Each fact-group consists
                                            of people who are told the same fact. And each fact-group must be able to
                                            tell everybody else about the fact. Let's precalculate for each subset of
                                            people whether they can become a fact-group. The subset can be a fact-group
                                            if set of all thier friends united with them is the whole set. After
                                            possible fact-groups are calculated, we have to determine maximal number of
                                            non-intersecting fact-groups in the set of people. We can define state
                                            domain (s)-&gt;R where s is subset of people and R is problem answer for
                                            them. To determine the answer for state s we have to subtract one of its
                                            fact-groups. It is a subset of s and forms a fact-group. So we can iterate
                                            through all subsets of s and try them as fact-groups.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  n </span><span class="pun">=</span><span class="pln"> matr</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> i</span><span class="pun">,</span><span class="pln"> j</span><span class="pun">,</span><span class="pln"> u</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                     </span><span class="com">//for all subsets i</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> mask </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i</span><span class="pun">&amp;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">j</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln">          </span><span class="com">//iterate through people in it</span><span class="pln">
  mask </span><span class="pun">|=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">j</span><span class="pun">);</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">matr</span><span class="pun">[</span><span class="pln">j</span><span class="pun">][</span><span class="pln">u</span><span class="pun">]==</span><span class="str">'Y'</span><span class="pun">)</span><span class="pln">   </span><span class="com">//accumulate the total set of informed people</span><span class="pln">
    mask </span><span class="pun">|=</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">u</span><span class="pun">);</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
cover</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">mask </span><span class="pun">==</span><span class="pln"> </span><span class="pun">(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">)-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">                 </span><span class="com">//if everyone is informed, the subset if fact-group</span><span class="pln">
</span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                     </span><span class="com">//go through states</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j </span><span class="pun">=</span><span class="pln"> i</span><span class="pun">;</span><span class="pln"> j</span><span class="pun">&gt;</span><span class="lit">0</span><span class="pun">;</span><span class="pln"> j </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">j</span><span class="pun">-</span><span class="lit">1</span><span class="pun">)&amp;</span><span class="pln">i</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">cover</span><span class="pun">[</span><span class="pln">j</span><span class="pun">])</span><span class="pln">    </span><span class="com">//iterate through all fact-group subsets</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">^</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">)</span><span class="pln">
    res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">^</span><span class="pln">j</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">                     </span><span class="com">//relax the result for i</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">ans </span><span class="pun">&lt;</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">])</span><span class="pln"> ans </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">];</span><span class="pln">                </span><span class="com">//relax the global answer</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> ans</span><span class="pun">;</span></code></pre>
                                        <p><strong>Breaking strings (ZOJ 2860)</strong></p>
                                        <p>This problem is solved with DP over substrings. Let's enumerate all required
                                            breaks and two ends of string with numbers 0, 1, 2, ..., k. Then res[L,R]
                                            will be result for the substring which starts in L-th point and ends in R-th
                                            point. To get this result we should look through all possible middle points
                                            M and consider res[L][M] + res[M][R] + (x[R]-x[L]) as a result. By doing
                                            this we get a clear O(k^3) solution (which is TL). What makes this problem
                                            exceptional is the application of Knuth's optimization. This trick works
                                            only for optimization DP over substrings for which optimal middle point
                                            depends monotonously on the end points. Let mid[L,R] be the first middle
                                            point for (L,R) substring which gives optimal result. It can be proven that
                                            mid[L,R-1] &lt;= mid[L,R] &lt;= mid[L+1,R] — this means monotonicity of mid
                                            by L and R. If you are interested in a proof, read about optimal binary
                                            search trees in Knuth's "The Art of Computer Programming" volume 3 binary
                                            search tree section. Applying this optimization reduces time complexity from
                                            O(k^3) to O(k^2) because with fixed s (substring length) we have m_right(L)
                                            = mid[L+1][R] = m_left(L+1). That's why nested L and M loops require not
                                            more than 2k iterations overall.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="pln">  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">&lt;=</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln">                    </span><span class="com">//s &amp;mdash; length(size) of substring</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> L </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> L</span><span class="pun">+</span><span class="pln">s</span><span class="pun">&lt;=</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> L</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">              </span><span class="com">//L &amp;mdash; left point</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> R </span><span class="pun">=</span><span class="pln"> L </span><span class="pun">+</span><span class="pln"> s</span><span class="pun">;</span><span class="pln">                            </span><span class="com">//R &amp;mdash; right point</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">2</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                              
    res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//DP base &amp;mdash; nothing to break</span><span class="pln">
    mid</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> l</span><span class="pun">;</span><span class="pln">                          </span><span class="com">//mid is equal to left border</span><span class="pln">
    </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> mleft </span><span class="pun">=</span><span class="pln"> mid</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">-</span><span class="lit">1</span><span class="pun">];</span><span class="pln">                  </span><span class="com">//Knuth's trick: getting bounds on M</span><span class="pln">
  </span><span class="kwd">int</span><span class="pln"> mright </span><span class="pun">=</span><span class="pln"> mid</span><span class="pun">[</span><span class="pln">L</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">R</span><span class="pun">];</span><span class="pln">
  res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000000000000LL</span><span class="pun">;</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> M </span><span class="pun">=</span><span class="pln"> mleft</span><span class="pun">;</span><span class="pln"> M</span><span class="pun">&lt;=</span><span class="pln">mright</span><span class="pun">;</span><span class="pln"> M</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">     </span><span class="com">//iterating for M in the bounds only</span><span class="pln">
    int64 tres </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">M</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">M</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="pun">(</span><span class="pln">x</span><span class="pun">[</span><span class="pln">R</span><span class="pun">]-</span><span class="pln">x</span><span class="pun">[</span><span class="pln">L</span><span class="pun">]);</span><span class="pln">
    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> tres</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                 </span><span class="com">//relax current solution</span><span class="pln">
      res</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> tres</span><span class="pun">;</span><span class="pln">
      mid</span><span class="pun">[</span><span class="pln">L</span><span class="pun">][</span><span class="pln">R</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> M</span><span class="pun">;</span><span class="pln">
    </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
int64 answer </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">k</span><span class="pun">];</span></code></pre>
                                        <p><strong>BlockEnemy</strong></p>
                                        <p>Since tree is given in the problem statement, we should try DP on subtrees
                                            first=) Given any correct solution for the whole tree, any subtree of it is
                                            also correct. So if all pairs of occupied towns are separated, then in each
                                            subtree they are also separated. So we can try to use state domain (v)-&gt;R
                                            where v represents subtree and R represents minimal effort to solve the
                                            problem for this subtree. But we'll discover soon that connecting subtrees
                                            correctly is impossible because we need to know whether there is an occupied
                                            town connected with outside part of subtree. We call such a solution for
                                            subtree dangerous. Now we add the boolean parameter (solution is
                                            safe/dangerous) in the state domain. Let res[v][t] be the minimal effort
                                            needed to get a correct solution for v-subtree which is dangerous(if
                                            d=1)/safe(if d=0). Initially we consider edge which is going out of subtree
                                            indestructible. We will handle the destruction of outgoing edge later. In
                                            this case, the solution for leaves is easy to obtain. If v is non-occupied
                                            leaf, then it forms a safe solution, and dangerous solution is impossible to
                                            get. If it is occupied, then the solution is dangerous with no effort, and
                                            impossible to make safe. Then if the vertex v is not leaf, we add its sons
                                            one by one. When adding a son s to v-subtree, we have the following merging
                                            rules: 1. v=safe + s=safe -&gt; v=safe 2. v=dangerous + s=safe -&gt;
                                            v=dangerous 3. v=safe + s=dangerous -&gt; v=dangerous 4. v=dangerous +
                                            s=dangerous -&gt; incorrect solution After merging by these rules, we
                                            receive a solution for v-subtree in case of indestructible outgoing edge.
                                            Now what changes if the outgoing edge is destructible? We can destruct it by
                                            paying additional effort. In this case a dangerous solution turns into safe
                                            one. The root of tree has no outgoing edge. The problem answer is minimal
                                            effort of safe and dangerous solutions for the root ot DFS tree. The time
                                            complexity is O(N^2) because adjacency matrix is used, but can be easily
                                            reduced to O(N) with neighbors lists.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">][</span><span class="lit">2</span><span class="pun">];</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> DFS</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">int</span><span class="pln"> f</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                            </span><span class="com">//traverse v-subtree, f is father of v</span><span class="pln">
vis</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">                                    </span><span class="com">//mark v as visited</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">occ</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">0</span><span class="pun">);</span><span class="pln">            </span><span class="com">//result in case of leaf</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="pun">(</span><span class="pln">occ</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">?</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">);</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">matr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">s</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">s</span><span class="pun">])</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                           </span><span class="com">//iterate over all sons</span><span class="pln">
DFS</span><span class="pun">(</span><span class="pln">s</span><span class="pun">,</span><span class="pln"> v</span><span class="pun">);</span><span class="pln">                                      </span><span class="com">//run DFS recursively</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> nres</span><span class="pun">[</span><span class="lit">2</span><span class="pun">];</span><span class="pln">                                
nres</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">0</span><span class="pun">];</span><span class="pln">                </span><span class="com">//safe case requires safe s and safe v</span><span class="pln">
nres</span><span class="pun">[</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">s</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]);</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nres</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln">                            </span><span class="com">//dangerous case requires dangerous + safe</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nres</span><span class="pun">[</span><span class="lit">1</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">f </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">f</span><span class="pun">])</span><span class="pln"> </span><span class="com">//we can destroy upgoing edge (v-f)</span><span class="pln">
res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">0</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> matr</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">f</span><span class="pun">];</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
DFS</span><span class="pun">(</span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">);</span><span class="pln">                                       </span><span class="com">//run DFS from 0 (with no father)</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> min</span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">                 </span><span class="com">//whether root is dangerous does not matter</span><span class="pln">
</span><span class="pun">}</span></code></pre>
                                        <p><strong>ConstructionFromMatches</strong></p>
                                        <p>We need to construct grid from matches obeying certain rules which have local
                                            effect. And the grid is 2 x n which is ideal for DP with profiles. Of
                                            course, it is better to slice the grid to 2-cell layers instead of N-cell
                                            ones. The profile consists of thicknesses of the last two vertical sticks.
                                            They are required to check sum when filling the next layer. To perform the
                                            transition, we have to iterate through all possible variants of next five
                                            sticks thicknesses and choose only variants that satisfy two equations on
                                            cell sums. If we perform it bruteforce, we will get O(N*K^7) algorithm,
                                            that's slow. It can be easily optimized if we calculate thicknesses of two
                                            sticks explicitly by using cell sum equations. This way the DP will be
                                            O(N*K^5) in time and O(N*K^2) in space. That is more than enough for the
                                            problem. If you want a better solution, you can notice that: 1. You can use
                                            "storing two layers" optimization and reduce space complexity to O(K^2). 2.
                                            You can transform the solution to DP with broken profiles. To do it you
                                            should add intermediate "half" states (i,p,b,v). hres[i][p][b][v] means
                                            minimal cost of full construction of (2*i+1) cells — i layers and a top cell
                                            in the next layer. The DP with broken profiles will require O(N*K^4) time
                                            and O(N*K^3) space, which can be reduced with technique 1 to O(K^3). The
                                            code for simple solution is given below. Since width of profile is
                                            well-known and very small, it is easier to write transition code as nested
                                            loops instead of recursive search.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="com">//...?? aa      //schema of profile and transition</span><span class="pln">
</span><span class="com">//...  u  p     //u and v comprise profile</span><span class="pln">
</span><span class="com">//...  u  p     //a, b, c, p, q are five added sticks</span><span class="pln">
</span><span class="com">//...?? bb      //system of equations is:</span><span class="pln">
</span><span class="com">//...  v  q     //{u + a + p + b = top[i]</span><span class="pln">
</span><span class="com">//...  v  q     //{v + b + q + c = bottom[i]</span><span class="pln">
</span><span class="com">//...?? cc      //the depicted transition leads to (i+1,p,q) state</span><span class="pln">

memset</span><span class="pun">(</span><span class="pln">res</span><span class="pun">,</span><span class="pln"> </span><span class="lit">63</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">res</span><span class="pun">));</span><span class="pln">                    </span><span class="com">//DP base</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln">                        </span><span class="com">//choose any two sticks</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln">                      </span><span class="com">//put them to leftmost vertical line</span><span class="pln">
  res</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">u</span><span class="pun">][</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">v</span><span class="pun">];</span><span class="pln">            </span><span class="com">//their cost is clear</span><span class="pln">

</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                  </span><span class="com">//iterate through states</span><span class="pln">
    </span><span class="kwd">int</span><span class="pln"> cres </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">][</span><span class="pln">u</span><span class="pun">][</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> a </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> a</span><span class="pun">++)</span><span class="pln">                  </span><span class="com">//choose a and p in all possible ways</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">
        </span><span class="kwd">int</span><span class="pln"> b </span><span class="pun">=</span><span class="pln"> top</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]-</span><span class="lit">4</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">mdash</span><span class="pun">;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">u </span><span class="pun">+</span><span class="pln"> a </span><span class="pun">+</span><span class="pln"> p</span><span class="pun">);</span><span class="pln">        </span><span class="com">//b is uniquely determined by top equation</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">b </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> b </span><span class="pun">&gt;=</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">         </span><span class="com">//though it can be bad...</span><span class="pln">
        </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">            </span><span class="com">//choose all possible q variants</span><span class="pln">
          </span><span class="kwd">int</span><span class="pln"> c </span><span class="pun">=</span><span class="pln"> bottom</span><span class="pun">[</span><span class="pln">i</span><span class="pun">]-</span><span class="lit">4</span><span class="pln"> </span><span class="pun">&amp;</span><span class="pln">mdash</span><span class="pun">;</span><span class="pln"> </span><span class="pun">(</span><span class="pln">v </span><span class="pun">+</span><span class="pln"> b </span><span class="pun">+</span><span class="pln"> q</span><span class="pun">);</span><span class="pln">   </span><span class="com">//c is uniquely determined by bottom equation</span><span class="pln">
          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">c </span><span class="pun">&lt;</span><span class="pln"> </span><span class="lit">0</span><span class="pln"> </span><span class="pun">||</span><span class="pln"> c </span><span class="pun">&gt;=</span><span class="pln"> k</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">

          </span><span class="kwd">int</span><span class="pln"> nres </span><span class="pun">=</span><span class="pln"> cres </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">q</span><span class="pun">]</span><span class="pln">  </span><span class="com">//the new solution cost</span><span class="pln">
                </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">a</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">b</span><span class="pun">]</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> cost</span><span class="pun">[</span><span class="pln">c</span><span class="pun">];</span><span class="pln">
          </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">q</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> nres</span><span class="pun">)</span><span class="pln">           </span><span class="com">//relaxing the destination</span><span class="pln">
            res</span><span class="pun">[</span><span class="pln">i</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">q</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> nres</span><span class="pun">;</span><span class="pln">
        </span><span class="pun">}</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">
  </span><span class="pun">}</span><span class="pln">

</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">;</span><span class="pln">                         </span><span class="com">//the last two sticks do not matter</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln">                        </span><span class="com">//choose the best variant among them</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">&lt;</span><span class="pln">k</span><span class="pun">;</span><span class="pln"> v</span><span class="pun">++)</span><span class="pln">
  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">answer </span><span class="pun">&gt;</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">n</span><span class="pun">][</span><span class="pln">u</span><span class="pun">][</span><span class="pln">v</span><span class="pun">])</span><span class="pln">
    answer </span><span class="pun">=</span><span class="pln"> res</span><span class="pun">[</span><span class="pln">n</span><span class="pun">][</span><span class="pln">u</span><span class="pun">][</span><span class="pln">v</span><span class="pun">];</span><span class="pln">
</span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">answer </span><span class="pun">&gt;=</span><span class="pln"> </span><span class="lit">1000000000</span><span class="pun">)</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="pun">-</span><span class="lit">1</span><span class="pun">;</span><span class="pln">           </span><span class="com">//do not forget "impossible" case</span></code></pre>
                                        <p><strong>GameWithGraphAndTree</strong></p>
                                        <p>This problem is solved by very tricky DP on the tree and subsets. We are
                                            required to find number of mappings of the tree on the graph. First of all,
                                            we choose root of the tree because it is easier to handle rooted tree.
                                            Clearly, we should consider all possible submapping of all subtrees on all
                                            vertex-subsets of the graph. The number of these submapping is huge, so we
                                            have to determine which properties of these submappings are important for
                                            extending the mapping. It turns out that these properties are: 1. Subtree
                                            denoted by its root vertex v. Necessary to check the outgoing edge mapping
                                            later. 2. Vertex of graph p which is the image of v. Again: necessary to
                                            check the mapping of added edge. 3. The full image of v-subtree in graph —
                                            set s of already mapped vertices in graph. Necessary to maintain bijectivity
                                            of mapping. Therefore we define state domain (v,p,s)-&gt;GR. GR is number of
                                            submappings with the properties we are interested in. To combine results of
                                            sons in tree we need to run another "internal" DP. Remember that internal DP
                                            is local for each vertex v of the tree. The first parameter will be number
                                            of sons already merged — this is quite standard. Also we'll use additional
                                            parameters p and s inside. The state domain is (k,p,s)-&gt;IR where IR is
                                            the number of submappings of partial v-subtree on graph with properties: 1.
                                            The vertex v and subtrees corresponding to its first k sons are being mapped
                                            (called domain). 2. Image of v is vertex p in graph. 3. The full image of
                                            mapping considered is s — subset of already used vertices. The transition of
                                            this internal DP is defined by adding one subtree corresponding to k-th son
                                            to the domain of mapping. For example, if w is the k-th son, then we add
                                            global state GR[w,q,t] to internal state IR[k,p,s] and get internal state
                                            IR[k+1,p,s+t]. Here we must check that there is an edge p-q in the graph and
                                            that sets s and t have no common elements. The combinations considered in
                                            GR[w,q,t] and IR[k,p,s] are independent, so we can just add their product to
                                            the destination state. The answer of internal DP is IR[sk,p,s] which is
                                            stored as a result GR[k,p,s] of global DP. This is correct solution of this
                                            problem. Unfortunately, it runs in O(4^N * N^3) if implemented like it is in
                                            the code below. Of course it gets TL. You need to optimize the solution even
                                            further to achieve the required performance. The recipe "Optimizing DP
                                            solution" describes how to get this solution accepted.</p>
                                        <pre><code class="prettyprint prettyprinted" style=""><span class="kwd">int</span><span class="pln"> gres</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">][</span><span class="pln">SIZE</span><span class="pun">];</span><span class="pln">                                </span><span class="com">//global DP on subtrees: (v,p,s)-&gt;GR</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> ires</span><span class="pun">[</span><span class="pln">MAXN</span><span class="pun">][</span><span class="pln">MAXN</span><span class="pun">][</span><span class="pln">SIZE</span><span class="pun">];</span><span class="pln">                                </span><span class="com">//internal DP: (k,p,s)-&gt;IR</span><span class="pln">

</span><span class="kwd">void</span><span class="pln"> DFS</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> v</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                                          </span><span class="com">//solve DP for v subtree</span><span class="pln">
vis</span><span class="pun">[</span><span class="pln">v</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln">
vector</span><span class="str">&lt;int&gt;</span><span class="pln"> sons</span><span class="pun">;</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> u </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> u</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">tree</span><span class="pun">[</span><span class="pln">v</span><span class="pun">][</span><span class="pln">u</span><span class="pun">]</span><span class="pln"> </span><span class="pun">&amp;&amp;</span><span class="pln"> </span><span class="pun">!</span><span class="pln">vis</span><span class="pun">[</span><span class="pln">u</span><span class="pun">])</span><span class="pln"> </span><span class="pun">{</span><span class="pln">   </span><span class="com">//visit all sons in tree</span><span class="pln">
DFS</span><span class="pun">(</span><span class="pln">u</span><span class="pun">);</span><span class="pln">                                                </span><span class="com">//calculate gres[u,...] recursively</span><span class="pln">
sons</span><span class="pun">.</span><span class="pln">push_back</span><span class="pun">(</span><span class="pln">u</span><span class="pun">);</span><span class="pln">                                     </span><span class="com">//ans save list of sons</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> sk </span><span class="pun">=</span><span class="pln"> sons</span><span class="pun">.</span><span class="pln">size</span><span class="pun">();</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="lit">0</span><span class="pun">],</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]));</span><span class="pln">                     </span><span class="com">//base of internal DP</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln"> ires</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">p</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="lit">1</span><span class="pun">;</span><span class="pln">          </span><span class="com">//one-vertex mappings v -&gt; p</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> k </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">&lt;</span><span class="pln">sk</span><span class="pun">;</span><span class="pln"> k</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                             </span><span class="com">//iterate through k &amp;mdash; number of sons considered</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> w </span><span class="pun">=</span><span class="pln"> sons</span><span class="pun">[</span><span class="pln">k</span><span class="pun">];</span><span class="pln">
memset</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">],</span><span class="pln"> </span><span class="lit">0</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">]));</span><span class="pln">               </span><span class="com">//remember to clear next layer</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> p </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> p</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                            </span><span class="com">//iterate through p &amp;mdash; image of v</span><span class="pln">
  </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> s </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> s</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> s</span><span class="pun">++)</span><span class="pln">                       </span><span class="com">//iterate through s &amp;mdash; full image of current domain</span><span class="pln">
    </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> q </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> q</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">graph</span><span class="pun">[</span><span class="pln">p</span><span class="pun">][</span><span class="pln">q</span><span class="pun">])</span><span class="pln">         </span><span class="com">//consider adding mapping which maps:</span><span class="pln">
      </span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> t </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> t</span><span class="pun">&lt;(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">);</span><span class="pln"> t</span><span class="pun">++)</span><span class="pln"> </span><span class="pun">{</span><span class="pln">                 </span><span class="com">//w -&gt; q;  w-subtree -&gt; t subset;</span><span class="pln">
        </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">s </span><span class="pun">&amp;</span><span class="pln"> t</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">continue</span><span class="pun">;</span><span class="pln">                           </span><span class="com">//do not break bijectivity</span><span class="pln">
        </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">+</span><span class="lit">1</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">s</span><span class="pun">^</span><span class="pln">t</span><span class="pun">],</span><span class="pln"> mult</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">k</span><span class="pun">][</span><span class="pln">p</span><span class="pun">][</span><span class="pln">s</span><span class="pun">],</span><span class="pln"> gres</span><span class="pun">[</span><span class="pln">w</span><span class="pun">][</span><span class="pln">q</span><span class="pun">][</span><span class="pln">t</span><span class="pun">]));</span><span class="pln">
      </span><span class="pun">}</span><span class="pln">                                                </span><span class="com">//add product of numbers to solution</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
memcpy</span><span class="pun">(</span><span class="pln">gres</span><span class="pun">[</span><span class="pln">v</span><span class="pun">],</span><span class="pln"> ires</span><span class="pun">[</span><span class="pln">sk</span><span class="pun">],</span><span class="pln"> </span><span class="kwd">sizeof</span><span class="pun">(</span><span class="pln">ires</span><span class="pun">[</span><span class="pln">sk</span><span class="pun">]));</span><span class="pln">             </span><span class="com">//since partial v-subtree with k=sk is full v-subtree</span><span class="pln">
</span><span class="pun">}</span><span class="pln">                                                          </span><span class="com">//we have GR[v,p,s] = IR[sk,p,s]</span><span class="pln">
</span><span class="pun">...</span><span class="pln">
DFS</span><span class="pun">(</span><span class="lit">0</span><span class="pun">);</span><span class="pln">                                                </span><span class="com">//launch DFS from root = 0-th vertex</span><span class="pln">
</span><span class="kwd">int</span><span class="pln"> answer </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln">                                        </span><span class="com">//consider all variants for i &amp;mdash; image of 0</span><span class="pln">
</span><span class="kwd">for</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">&lt;</span><span class="pln">n</span><span class="pun">;</span><span class="pln"> i</span><span class="pun">++)</span><span class="pln"> </span><span class="kwd">add</span><span class="pun">(</span><span class="pln">answer</span><span class="pun">,</span><span class="pln"> gres</span><span class="pun">[</span><span class="lit">0</span><span class="pun">][</span><span class="pln">i</span><span class="pun">][(</span><span class="lit">1</span><span class="pun">&lt;&lt;</span><span class="pln">n</span><span class="pun">)-</span><span class="lit">1</span><span class="pun">]);</span><span class="pln">
</span><span class="kwd">return</span><span class="pln"> answer</span><span class="pun">;</span><span class="pln">                                         </span><span class="com">//sum this variants up and return as an answer</span><span class="pln">
</span><span class="pun">}</span><span class="pln">
</span><span class="pun">};</span></code></pre>
                                    </div>
                                </div>


                                <script type="text/javascript">
                                    $(document).ready(function () {
                                        $(".delete-resource-link-38552-43366").click(function () {
                                            var that = this;
                                            Codeforces.confirm("Are you sure you want to detach a contest?", function () {
                                                $.post("/data/blogAndContest", {
                                                    action: "detachBlogFromContest",
                                                    blogId: "38552",
                                                    blogEntryId: "43256",
                                                    contestId: $(that).attr("data-contestId"),
                                                    resourceIds: $(that).attr("data-resourceIds")
                                                }, function (json) {
                                                    Codeforces.reloadAndShowMessageOrShowError(json, "Contest detached");
                                                });
                                            }, function () { }, "Yes", "No");
                                        });
                                    });
                                </script>







                                <style type="text/css">
                                    .comments .title {
                                        float: left;
                                    }

                                    .comments .comments-actions-div {
                                        float: right;
                                        margin-top: 3rem;
                                        margin-right: 0.5em;
                                    }

                                    .comments .comments-actions-div .separator {
                                        margin: 0 1rem;
                                    }

                                    .comments label.show-archived {}

                                    .comments label.show-archived,
                                    .comments label.show-archived * {
                                        font-size: 1.4rem !important;
                                        color: black !important;
                                        /*position: relative !important;*/
                                        /*bottom: 0.4rem !important;*/
                                    }

                                    .comments label.show-archived input {
                                        height: 1.4rem !important;
                                        width: 1.4rem !important;
                                        position: relative;
                                        top: 0.25rem;
                                    }

                                    .new-root-comment {
                                        font-size: 1.4rem !important;
                                    }
                                </style>

                                <div class="comments" commentableid="43383">










                                    <div class="comment">

                                        <ul class="comment-children comment-280031">
                                        </ul>
                                    </div>

                                    <div class="comment">
                                        <table class="comment-table" commentid="420346" commentparentid="-1">
                                            <tbody>
                                                <tr>


                                                </tr>
                                            </tbody>
                                        </table>
                                        <ul class="comment-children comment-420346">
                                        </ul>
                                    </div>







                                    <div class="comment">


                                    </div>










                                    <br>

                                    <div id="editBox-43383" style="width:50em;display:none;">
                                        <div class="previewBody"
                                            style="border: 1px solid #d4d4d4; margin-bottom: 0.5em; padding: 0.25em; display:none;">
                                            &nbsp;</div>
                                        <div style="width: 1px">&nbsp;</div>
                                        <div class="commentLocale"
                                            style="position: relative; top: 0.5em;left:4px;display: none;">
                                            <input type="radio" name="locale" value="en"><span
                                                style="font-size: 1.2rem;position: relative; bottom: 3px;">In
                                                English</span>
                                            <input style="margin-left:1em" type="radio" name="locale" value="ru"><span
                                                style="font-size: 1.2rem;position: relative; bottom: 3px;">In
                                                Russian</span>
                                        </div>
                                        <textarea data-drafts-id="CommentReplyFrame" class="wysiwyg" name="editContent"
                                            rows="20" style="width:99%;"></textarea>
                                        <div class="error error__content"></div>
                                        <div style="text-align:center;">
                                            <input type="button" name="preview"
                                                style="padding: 0.25em 1em; margin-top: 1em; min-width: 6.5em;"
                                                value="Preview">
                                            <input type="button" name="save"
                                                style="padding: 0.25em 1em; margin-top: 1em; min-width: 6.5em;"
                                                value="Save">
                                        </div>
                                    </div>

                                    <script type="text/javascript">
                                        $(document).ready(function () {

                                            var firstPreview43383 = true;
                                            var lastPreviewContent43383 = '';

                                            if (!window.moveCommentRevision) {
                                                moveCommentRevision = function (e, dir) {
                                                    var p = e.parent();
                                                    var revisionCount = parseInt(p.attr("revisionCount"));
                                                    var revision = parseInt(p.attr("revision"));
                                                    var next = revision + dir;
                                                    var commentId = p.attr("commentId");
                                                    if (next >= 1 && next <= revisionCount) {
                                                        $.post(
                                                            "/data/comment-data",
                                                            { action: "revision", commentId: commentId, revision: next },
                                                            function (json) {
                                                                if (json.success == "true") {
                                                                    var parentDiv = e;

                                                                    while (parentDiv !== null && (parentDiv[0].nodeName.toLowerCase() !== "td" || !parentDiv.hasClass("right"))) {
                                                                        parentDiv = parentDiv.parent();
                                                                    }

                                                                    if (parentDiv === null) {
                                                                        return;
                                                                    }

                                                                    parentDiv.find("div.comment-content-" + commentId + " .moveup").html(json.content);
                                                                    Codeforces.setupSpoilers(parentDiv.find("div.comment-content-" + commentId + " .moveup"));
                                                                    p.attr("revision", next);
                                                                    p.find("span.revision").text(next);
                                                                    if (next == 1) {
                                                                        p.find("a.leftRevision").css("visibility", "hidden");
                                                                    } else {
                                                                        p.find("a.leftRevision").css("visibility", "visible");
                                                                    }
                                                                    if (next == revisionCount) {
                                                                        p.find("a.rightRevision").css("visibility", "hidden");
                                                                    } else {
                                                                        p.find("a.rightRevision").css("visibility", "visible");
                                                                    }

                                                                    window.updateTypography();
                                                                    MathJax.Hub.Typeset();
                                                                } else {
                                                                    alert(e.error);
                                                                }
                                                            },
                                                            "json"
                                                        );
                                                    }
                                                };
                                            }

                                            $("div[commentableId=43383] a.leftRevision").click(function () {
                                                window.moveCommentRevision($(this), -1);
                                                return false;
                                            });

                                            $("div[commentableId=43383] a.rightRevision").click(function () {
                                                window.moveCommentRevision($(this), +1);
                                                return false;
                                            });

                                            $("div[commentableId=43383] a.editCommentLink").click(function () {
                                                if (confirm("You may edit your comment only for fixing grammar mistakes or small changes. Do not change the main idea of your comment. All previous revisions are available for others. Are you sure you want to edit comment?")) {
                                                    Codeforces.facebox("#editBox-43383", "//cdn.codeforces.com/s/57914");
                                                    firstPreview43383 = true;
                                                    lastPreviewContent43383 = '';
                                                    $("#facebox #editBox-43383 textarea.wysiwyg").drafts({ textDrafts: "Drafts", textUseIt: "Use it", url: "/data/draft", saveErrorMessage: "Can't save draft. Possibly connection is lost or session is expired. Stay on the page (cancel to reload)?" });
                                                    var commentId = $(this).attr("commentId");
                                                    $.post("/data/comment-data", { action: "content", commentId: commentId }, function (json) {
                                                        if (json["success"] != "true") {
                                                            alert(json["error"]);
                                                            return;
                                                        }
                                                        var content = json["content"];
                                                        $("#facebox #editBox-43383 textarea.wysiwyg").val(content);

                                                        if (json["allowChangeLocale"] == "true") {
                                                            $("#facebox #editBox-43383 .commentLocale").css("display", "");
                                                        }

                                                        var commentLocale = json["commentLocale"];
                                                        if (commentLocale == "en") {
                                                            $("#facebox #editBox-43383 .commentLocale input[value=en]").prop("checked", true);
                                                        } else {
                                                            $("#facebox #editBox-43383 .commentLocale input[value=ru]").prop("checked", true);
                                                        }

                                                        $("#facebox #editBox-43383 textarea.wysiwyg").css("width", "97%").markItUp(commentSettings).css("height", "200px").focus();

                                                        $("#facebox #editBox-43383 input[name='save']").click(function () {
                                                            var content = $("#facebox #editBox-43383 textarea.wysiwyg").val();
                                                            var locale = $("#facebox #editBox-43383 input[name=locale]:checked").val();
                                                            $.post(
                                                                "/data/comment-data",
                                                                { action: "update", commentId: commentId, content: content, locale: locale, subscribedCommentLinkInfix: "QOLP-SFZMFB6HDC3f4bjkE5VEX0*/blog/entry/43256" },
                                                                function (json) {
                                                                    if (json.success == "true") {
                                                                        Codeforces.reload();
                                                                    } else {
                                                                        $("#facebox #editBox-43383 div.error__content").text(json.error__content);
                                                                        window.updateTypography();
                                                                    }
                                                                },
                                                                "json"
                                                            );

                                                            return false;
                                                        });

                                                        $("#facebox #editBox-43383 input[name='preview']").click(function () {
                                                            var content = $("#facebox #editBox-43383 textarea[name='editContent']").val();
                                                            if (firstPreview43383 || lastPreviewContent43383 != content) {
                                                                firstPreview43383 = false;
                                                                lastPreviewContent43383 = content;
                                                                commentPreviewShow43383(commentId);
                                                            }
                                                            return false;
                                                        });
                                                    }, "json");
                                                }
                                                return false;
                                            });

                                            var commentPreviewShow43383 = function (commentId) {
                                                var content = $("#facebox #editBox-43383 textarea[name='editContent']").val();
                                                var replyLocale = $("#facebox #editBox-43383 input[name=locale]:checked").val();
                                                $.post(
                                                    "/data/comment-data", { action: "preview", replyLocale: replyLocale, content: content, commentId: commentId },
                                                    function (json) {
                                                        if (json.success == "true") {
                                                            $("#facebox #editBox-43383 .previewBody").html("<div style='font-size: 1.2rem;'>Comment preview:<hr/></div><div class='comment-content' style='position: relative; bottom: 12px;'>" + json.response + "</div>").fadeIn();
                                                            Codeforces.setupSpoilers($("#facebox #editBox-43383 .previewBody"));
                                                            MathJax.Hub.Typeset();
                                                        } else {
                                                            $("#facebox #editBox-43383 .previewBody").html("<div><b style='color:red;'>Comment preview error:</b><hr/><div>" + json.error__content).fadeIn();
                                                        }
                                                        window.updateTypography();
                                                    },
                                                    "json"
                                                );
                                                return false;
                                            };

                                            $("div[commentableId=43383] a.deleteCommentLink").click(function () {
                                                if (confirm("Are you sure you want to delete this comment?")) {
                                                    var commentId = $(this).attr("commentId");
                                                    $.post("/data/comment-data", { action: "delete", commentId: commentId }, function (json) {
                                                        if (json.success == "true") {
                                                            Codeforces.reload();
                                                        } else {
                                                            alert(json.error);
                                                        }
                                                    }, "json");
                                                }
                                                return false;
                                            });

                                        });
                                    </script>

                                    <div class="comment comment-reply-prototype" style="display:none;">
                                        <table class="comment-table" style="width: 100%;">
                                            <tbody>
                                                <tr>
                                                    <td class="left">
                                                        <div class="avatar">
                                                            <a href="https://codeforces.com/profile/Letscode_sundar"
                                                                style="position: relative;">
                                                                <img
                                                                    src="./Everything About Dynamic Programming - Codeforces_files/47ceabb276a5f658.jpg">
                                                            </a>
                                                            <div><a href="https://codeforces.com/profile/Letscode_sundar"
                                                                    title="Specialist Letscode_sundar"
                                                                    class="rated-user user-cyan">Letscode_sundar</a>
                                                            </div>
                                                        </div>
                                                    </td>
                                                    <td class="right" style="padding:1em 0 1em 1em;">
                                                        <form action="https://codeforces.com/blog/entry/43256"
                                                            method="post" class="commentReplyForm"><input type="hidden"
                                                                name="csrf_token"
                                                                value="07683b4c33a0837f3e2306e143fb0495">
                                                            <input type="hidden" name="commentReplyFormSubmitted"
                                                                value="true">
                                                            <input type="hidden" name="commentId">
                                                            <input type="hidden" name="hasMaximalDepth">
                                                            <input type="hidden" name="commentableId">
                                                            <table class="table-form" style="width:100%;">
                                                                <tbody>
                                                                    <tr>
                                                                        <td style="width: 1px">&nbsp;</td>
                                                                        <td>
                                                                            <div
                                                                                style="position: relative; top: 0.5em;left:4px;">
                                                                                <input type="radio" name="locale"
                                                                                    value="en"><span
                                                                                    style="font-size: 1.2rem;position: relative; bottom: 3px;">In
                                                                                    English</span>
                                                                                <input style="margin-left:1em"
                                                                                    type="radio" name="locale"
                                                                                    value="ru"><span
                                                                                    style="font-size: 1.2rem;position: relative; bottom: 3px;">In
                                                                                    Russian</span>
                                                                            </div>
                                                                        </td>
                                                                    </tr>
                                                                    <tr>
                                                                        <td style="width: 1px;">&nbsp;</td>
                                                                        <td>
                                                                            <div class="previewBody"
                                                                                style="border: 1px solid #d4d4d4; margin-bottom: 0.5em; padding: 0.25em; display:none;">
                                                                                &nbsp;</div>
                                                                            <textarea data-drafts-id="CommentReplyFrame"
                                                                                class="no-wysiwyg" name="replyContent"
                                                                                rows="10"
                                                                                style="width: 100%;"></textarea>
                                                                        </td>
                                                                    </tr>
                                                                    <tr>
                                                                        <td colspan="2" valign="top">
                                                                            <div style="float:left; margin-left:6px;"
                                                                                class="smaller notice">This post was
                                                                                published a long time ago. Please
                                                                                refrain from commenting unless you have
                                                                                a really reasonable cause to leave a
                                                                                comment. Necroposting is discouraged by
                                                                                the community.</div>

                                                                            <div style="float: left;" class="small">
                                                                                <div
                                                                                    class="shiftUp error__commentWithId">
                                                                                    <span
                                                                                        class="error for__commentWithId "
                                                                                        style="display: none;">&nbsp;</span>
                                                                                    <span
                                                                                        class="notice for__commentWithId ">&nbsp;</span>
                                                                                </div>
                                                                                <div class="shiftUp error__content">
                                                                                    <span class="error for__content "
                                                                                        style="display: none;">&nbsp;</span>
                                                                                    <span
                                                                                        class="notice for__content ">&nbsp;</span>
                                                                                </div>
                                                                            </div>
                                                                            <div
                                                                                style="position: relative; right: 4px;text-align:right;">
                                                                                <div
                                                                                    style="position: relative; display: inline-block;">
                                                                                    <img style="left:-24px;"
                                                                                        class="ajax-loading-gif"
                                                                                        src="./Everything About Dynamic Programming - Codeforces_files/ajax-loading-16x16.gif">
                                                                                    <input
                                                                                        style="font-size: 0.7em;height:1.8em;padding:0 0.75em;"
                                                                                        type="submit" name="submit"
                                                                                        value="Post">
                                                                                    <input
                                                                                        style="font-size: 0.7em;height:1.8em;padding:0 0.75em;"
                                                                                        type="button" class="preview"
                                                                                        value="Preview">
                                                                                    <input
                                                                                        style="font-size: 0.7em;height:1.8em;padding:0 0.75em;"
                                                                                        type="button" class="cancel"
                                                                                        value="Cancel">
                                                                                </div>
                                                                            </div>
                                                                        </td>
                                                                    </tr>
                                                                </tbody>
                                                            </table>
                                                            <input type="hidden" name="_tta" value="740">
                                                        </form>
                                                    </td>
                                                </tr>
                                            </tbody>
                                        </table>
                                    </div>

                                    <script type="text/javascript">
                                        $(function () {
                                            window._ftaa = "uwkox8jxl7n9pdmtyj";
                                        })
                                    </script>

                                    <script type="text/javascript">
                                        $(function () {
                                            window._bfaa = "a0f57a84655455c1858c7d97efdfc016";
                                        });
                                    </script>

                                    <script type="text/javascript">
                                        $(document).ready(function () {
                                            var commentPreviewListener = function (div) {
                                                var content = div.find("textarea").val();
                                                var replyLocale = div.find('input[name=locale]:checked').val();

                                                $.post(
                                                    "/data/comment-data",
                                                    { action: "preview", replyLocale: replyLocale, content: content },
                                                    function (json) {
                                                        if (json.success == "true") {
                                                            div.find(".previewBody").html("<div style='font-size: 1.2rem;'>Comment preview:<hr/></div><div class='comment-content' style='position: relative; bottom: 12px;'>" + json.response + "</div>").fadeIn();
                                                            Codeforces.setupSpoilers(div.find(".previewBody"));
                                                            MathJax.Hub.Typeset();
                                                        } else {
                                                            div.find(".previewBody").html("<div><b style='color:red;'>Comment preview error:</b><hr/><div>" + json.error__content).fadeIn();
                                                        }
                                                        window.updateTypography();
                                                    },
                                                    "json"
                                                );

                                                return false;
                                            }

                                            var commentReplyFormSubmitListener = function () {
                                                if (!confirm("The post on which you are writing a comment was written a long time ago. Please refrain from commenting unless you have a really reasonable cause to leave a comment. Necroposting is discouraged by the community. Are you sure you want to publish the comment?")) {
                                                    return false;
                                                }

                                                var id = $(this).attr("id");
                                                var hasMaximalDepth = $(this).find("input[name=hasMaximalDepth]").val() || "false";
                                                var commentWithId = $(this).find("input[name=commentId]").val() || "";
                                                var content = $(this).find("textarea").val();
                                                var commentableId = $(this).find("input[name=commentableId]").val() || 0;
                                                var commentReplyFormSubmitted = $(this).find("input[name=commentReplyFormSubmitted]").val();
                                                var replyLocale = $(this).find('input[name=locale]:checked').val();

                                                var postNewCommentReply = function () {
                                                    $.post(
                                                        "/data/new-comment-reply",
                                                        { ftaa: window._ftaa, bfaa: window._bfaa, commentWithId: commentWithId, content: content, commentReplyFormSubmitted: commentReplyFormSubmitted, _tta: Codeforces.tta(), replyLocale: replyLocale, commentableId: commentableId, subscribedCommentLinkInfix: "QOLP-SFZMFB6HDC3f4bjkE5VEX0*/blog/entry/43256" },
                                                        function (data) {
                                                            var invalid = Codeforces.setAjaxFormErrors("#" + id, data);
                                                            var newCommentWithId = data.newCommentWithId;
                                                            if (!invalid) {
                                                                var s = window.location.toString();
                                                                var found = false;
                                                                for (var i = 0; i < s.length; i++)
                                                                    if (s.charAt(i) == '#') {
                                                                        found = true;
                                                                        index = i;
                                                                    }
                                                                if (!found) {
                                                                    s += "#" + newCommentWithId;
                                                                } else {
                                                                    s = s.substr(0, index + 1) + newCommentWithId;
                                                                }
                                                                window.location = s;
                                                                window.location.reload();
                                                            }
                                                        },
                                                        "json"
                                                    );
                                                };

                                                $.post("/data/checkTextForRussianLanguage", { text: content }, function (response) {
                                                    var isRussianComment = response["isRussianComment"];
                                                    if (replyLocale == "en" && isRussianComment == "true") {
                                                        Codeforces.confirm(
                                                            "Are you sure that your comment in English?",
                                                            postNewCommentReply, function () { },
                                                            "Yes", "No"
                                                        );
                                                    } else if (replyLocale == "ru" && isRussianComment == "false") {
                                                        Codeforces.confirm(
                                                            "Are you sure that your comment in Russian?",
                                                            postNewCommentReply, function () { },
                                                            "Yes", "No"
                                                        );
                                                    } else {
                                                        postNewCommentReply();
                                                    }
                                                }, "json");

                                                return false;
                                            }
                                            $("a.new-root-comment").click(function () {
                                                var a = $(this);
                                                a.hide();

                                                var commentableId = $(".comments").attr("commentableId");
                                                var e = $(".comment-reply-prototype").clone().removeClass("comment-reply-prototype");

                                                var div = $("<div></div>").append(e);
                                                var p = $(this).parent().parent();
                                                p.append(div);
                                                e.show();

                                                e.find("input[value=en]").attr("checked", true);
                                                e.find("input[name=commentableId]").attr("value", commentableId);
                                                e.find("form").submitOnce(commentReplyFormSubmitListener, true);
                                                e.find("form").attr("id", "form-" + (new Date().getTime()));

                                                div.find('textarea.no-wysiwyg').css("width", "97%").markItUp(commentSettings).css("height", "200px");
                                                div.find('textarea.no-wysiwyg').removeClass("no-wysiwyg");
                                                div.find('textarea').drafts({ textDrafts: "Drafts", textUseIt: "Use it", url: "/data/draft", saveErrorMessage: "Can't save draft. Possibly connection is lost or session is expired. Stay on the page (cancel to reload)?" });
                                                div.find('textarea').focus();

                                                var first = true;
                                                div.find(".cancel").each(function () {
                                                    if (first) {
                                                        $(this).click(function () {
                                                            div.remove();
                                                            a.show();
                                                            return false;
                                                        });
                                                        first = false;
                                                    }
                                                });

                                                first = true;
                                                div.find(".preview").each(function () {
                                                    if (first) {
                                                        $(this).click(function () {
                                                            commentPreviewListener(div);
                                                            return false;
                                                        });
                                                        first = false;
                                                    }
                                                });
                                                return false;
                                            });

                                            $(".comment-table .reply a").click(function () {
                                                var classes = this.className.split(" ");
                                                var commentId = classes[0];
                                                var locale = classes[1];
                                                var hasMaximalDepth = classes[2];
                                                var commentableId = $(".comments").attr("commentableId");

                                                showReplyWindow = function () {
                                                    $(".current-comment-reply").remove();
                                                    var e = $(".comment-reply-prototype").clone().removeClass("comment-reply-prototype").addClass("current-comment-reply");

                                                    var li = $("<li></li>").append(e);
                                                    var ul = $(".comment ul." + commentId);
                                                    ul.prepend(li);
                                                    e.show();
                                                    e.find("input[name=commentId]").attr("value", commentId);
                                                    e.find("input[name=hasMaximalDepth]").attr("value", hasMaximalDepth);
                                                    e.find("input[value=" + locale + "]").attr("checked", true);
                                                    e.find("input[name=locale]").attr("readonly", true);
                                                    e.find("input[name=locale]").attr("disabled", true);
                                                    e.find("input[name=commentableId]").attr("value", commentableId);
                                                    e.find("form").submitOnce(commentReplyFormSubmitListener, true);
                                                    e.find("form").attr("id", "form-" + (new Date().getTime()));

                                                    li.find('textarea').css("width", "97%").markItUp(commentSettings).css("height", "200px").focus();

                                                    setTimeout(function () {
                                                        li.find('textarea').drafts({ textDrafts: "Drafts", textUseIt: "Use it", url: "/data/draft", saveErrorMessage: "Can't save draft. Possibly connection is lost or session is expired. Stay on the page (cancel to reload)?" });
                                                    }, 1000);

                                                    var first = true;
                                                    ul.find(".cancel").each(function () {
                                                        if (first) {
                                                            $(this).click(function () {
                                                                li.remove();
                                                                return false;
                                                            });
                                                            first = false;
                                                        }
                                                    });

                                                    first = true;
                                                    ul.find(".preview").each(function () {
                                                        if (first) {
                                                            $(this).click(function () {
                                                                commentPreviewListener(ul);
                                                            });
                                                            first = false;
                                                        }
                                                    });
                                                }

                                                if (hasMaximalDepth == "true") {
                                                    Codeforces.confirm("The debates reached maximal permitted depth, so your message and the message you are replying will be displayed on the same level. Are you sure you want to reply to the message?", showReplyWindow, function () { }, "Yes", "No");
                                                } else {
                                                    showReplyWindow();
                                                }
                                                return false;
                                            });
                                        });
                                    </script>
                                    <script type="text/javascript">
                                        $(document).ready(function () {
                                            $(".vote-for-comment").mouseover(function () {
                                                var vote = $(this);
                                                var direction = vote.attr("voteDirection");
                                                var commentUserId = $(this).parent().attr("data-commentUserId");
                                                var ownComment = commentUserId == 1712906;
                                                if (direction == 1 && !ownComment) {
                                                    vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-voteup.png");
                                                    vote.find("img").attr("popacity", vote.find("img").css("opacity"));
                                                    vote.find("img").css("opacity", "1.0");
                                                }
                                                if (direction == -1 && !ownComment) {
                                                    vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-votedown.png");
                                                    vote.find("img").attr("popacity", vote.find("img").css("opacity"));
                                                    vote.find("img").css("opacity", "1.0");
                                                }
                                            });

                                            $(".vote-for-comment").mouseout(function () {
                                                var vote = $(this);
                                                var direction = vote.attr("voteDirection");
                                                var commentUserId = $(this).parent().attr("data-commentUserId");
                                                var ownComment = commentUserId == 1712906;
                                                if (direction == 1 && !ownComment) {
                                                    vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-voteup-blue.png");
                                                    vote.find("img").css("opacity", vote.find("img").attr("popacity"));
                                                }
                                                if (direction == -1 && !ownComment) {
                                                    vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-votedown-blue.png");
                                                    vote.find("img").css("opacity", vote.find("img").attr("popacity"));
                                                }
                                            });

                                            $(".vote-for-comment").click(function () {
                                                var vote = $(this);
                                                var commentId = $(this).parent().attr("commentid");
                                                var commentRating = $(this).parent().attr("data-commentRating");
                                                var direction = $(this).attr("voteDirection");
                                                var commentUserId = $(this).parent().attr("data-commentUserId");
                                                var ownComment = commentUserId == 1712906;
                                                $.post("/data/comment/vote", { commentId: commentId, _tta: Codeforces.tta(), vote: direction, commentRating: commentRating }, function (data) {
                                                    if (direction != 0 && !ownComment && data["success"] == "true") {
                                                        vote.parent().find(".vote-for-comment").attr("voteDirection", 0);
                                                        if (direction == 1)
                                                            vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-voteup.png");
                                                        else
                                                            vote.find("img").attr("src", "//cdn.codeforces.com/s/57914/images/actions/comment-votedown.png");
                                                        vote.find("img").attr("popacity", "1.0");
                                                        vote.find("img").css("opacity", "1.0");
                                                        vote.parent().find(".commentRating").html(data["commentRating"]);
                                                    }
                                                    Codeforces.showMessage(data["message"]);
                                                }, "json");
                                                return false;
                                            });

                                            $(".negative-comment-vote").closest(".comment-table").addClass("comment-bad");

                                            $(".troll-comment-vote").closest(".comment").css("display", "none");

                                            $(".too-negative-comment-vote").closest(".comment-table").each(function () {
                                                var e = $(this);
                                                e.addClass("comment-too-bad");
                                                var commentId = e.attr("commentId");
                                                $("<div class='bad-comment-replacement ttypography'>The comment is hidden because of too negative feedback, click <a href=# class=show-bad-comment-link>here</a> to view it</div>").appendTo(
                                                    e.find(".right")
                                                );
                                                e.find(".comment-content").hide();
                                                e.find(".show-bad-comment-link").click(function () {
                                                    e.find(".comment-content").show();
                                                    e.find(".bad-comment-replacement").hide();
                                                    return false;
                                                });
                                            });
                                        });
                                    </script>
                                </div>

                                <style type="text/css">
                                    .new-comments-box {
                                        padding: 0.5em;
                                        width: 22px;
                                        font-size: 1.3rem;
                                        font-weight: bold !important;

                                        position: fixed;
                                        top: 40%;
                                        right: 0;
                                        opacity: 0.2;
                                        color: white;
                                        text-align: center;

                                        border: 1px solid #222;
                                        background-color: #888 !important;
                                        border-radius: 3px;
                                        -moz-border-radius: 3px;
                                        -webkit-border-radius: 3px;
                                    }

                                    .new-comments-box:hover {
                                        opacity: 1;
                                    }

                                    .new-comments-box .dir:hover {
                                        background: #3B5998 !important;
                                        cursor: pointer;
                                    }
                                </style>

                                <div class="new-comments-box" data-position="outside" data-index="-1"
                                    style="display: none;">
                                    <div class="up dir" title="Ctrl+Up">↑
                                        <hr>
                                    </div>
                                    <div class="info" title="New comments"></div>
                                    <div class="down dir" title="Ctrl+Down">
                                        <hr>↓
                                    </div>
                                </div>

                                <script>
                                    $(".show-archived-checkbox").change(function () {
                                        const checked = $(this).is(":checked");
                                        $.post("/data/comment-data", { action: "setShowArchived", checked }, function (json) {
                                            if (json["success"] !== "true") {
                                                alert(json["error"]);
                                            } else {
                                                if (checked) {
                                                    Codeforces.reloadAndShowMessage("Archived comments are now displayed")
                                                } else {
                                                    Codeforces.reloadAndShowMessage("Archived comments are no longer displayed")
                                                }
                                            }
                                        });
                                        return false;
                                    });

                                    function gotoComment(direction) {
                                        var box = $(".new-comments-box");
                                        var index = parseInt(box.attr("data-index"));
                                        if (index == -1)
                                            index = 0;
                                        else
                                            index = Math.max(0, Math.min(parseInt(box.find(".info").text()) - 1, index + direction));
                                        box.attr("data-index", index);
                                        var comment = $($(".comment .highlight-blue[commentId]").get(index));
                                        $('html, body').animate({
                                            'scrollTop': Math.max(0, comment.offset().top - ($(window).height() - comment.height()) / 2)
                                        });
                                        return false;
                                    }

                                    $(".new-comments-box .down").click(function () {
                                        return gotoComment(1);
                                    });

                                    $(".new-comments-box .up").click(function () {
                                        return gotoComment(-1);
                                    });

                                    $(document).keydown(function (e) {
                                        var code = (e.keyCode ? e.keyCode : e.which);
                                        if (e.ctrlKey) {
                                            if (code == 38 || code == 40) {
                                                gotoComment(code - 39);
                                            }
                                        }
                                    });

                                    var newCommentCount = $(".comment .highlight-blue[commentId]").length;
                                    if (newCommentCount > 0) {
                                        $(".new-comments-box .info").text(newCommentCount);
                                        $(".new-comments-box").show();
                                    }

                                    $('table.comment-table').mouseenter(function () {
                                        var comment = $(this);
                                        var cnt = 0;
                                        while (true) {
                                            var id = comment.attr("commentId");
                                            var parentId = comment.attr("commentParentId");
                                            comment.find(".comment-indent-holder:first .comment-no-indent").addClass("comment-indent");
                                            if (parentId == -1) {
                                                break;
                                            }
                                            comment = $("table.comment-table[commentId=" + parentId + "]");
                                        }
                                        return false;
                                    });

                                    $('table.comment-table').mouseleave(function () {
                                        var comment = $(this);
                                        var cnt = 0;
                                        while (true) {
                                            var id = comment.attr("commentId");
                                            var parentId = comment.attr("commentParentId");
                                            comment.find(".comment-indent-holder:first .comment-no-indent").removeClass("comment-indent");
                                            if (parentId == -1) {
                                                break;
                                            }
                                            comment = $("table.comment-table[commentId=" + parentId + "]");
                                        }
                                        return false;
                                    });
                                </script>


                                <script type="text/javascript">
                                    $(document).ready(function () {
                                        $(".topic-vote-up-43366").click(function () {
                                            $.post("/data/topic/vote", { topicId: 43366, _tta: Codeforces.tta(), topicRevisionId: 95506, vote: +1 }, function (data) {
                                                Codeforces.showMessage(data);
                                            }, "json");
                                            return false;
                                        });
                                        $(".topic-vote-down-43366").click(function () {
                                            $.post("/data/topic/vote", { topicId: 43366, _tta: Codeforces.tta(), topicRevisionId: 95506, vote: -1 }, function (data) {
                                                Codeforces.showMessage(data);
                                            }, "json");
                                            return false;
                                        });
                                    });
                                </script>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <br style="clear: both;">

            <script type="text/javascript">
                $(function () {
                    $(".switchToMobile").click(function () {
                        Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, "mobile", "true"));
                        return false;
                    });
                    $(".switchToDesktop").click(function () {
                        Codeforces.redirect(Codeforces.updateUrlParameter(document.location.href, "mobile", "false"));
                        return false;
                    });
                });
            </script>
            <script type="text/javascript">
                $(document).ready(function () {
                    if ($(window).width() < 1600) {
                        $('.button-up').css('width', '30px').css('line-height', '30px').css('font-size', '20px');
                    }

                    if ($(window).width() >= 1200) {
                        $(window).scroll(function () {
                            if ($(this).scrollTop() > 100) {
                                $('.button-up').fadeIn();
                            } else {
                                $('.button-up').fadeOut();
                            }
                        });

                        $('.button-up').click(function () {
                            $('body,html').animate({
                                scrollTop: 0
                            }, 500);
                            return false;
                        });

                        $('.button-up').hover(function () {
                            $(this).animate({
                                'opacity': '1'
                            }).css({ 'background-color': '#e7ebf0', 'color': '#6a86a4' });
                        }, function () {
                            $(this).animate({
                                'opacity': '0.7'
                            }).css({ 'background': 'none', 'color': '#d3dbe4' });;
                        });
                    }
                    Codeforces.focusOnError();
                });
            </script>
            <div class="userListsFacebox" style="display:none;">
                <div style="padding: 0.5em; width: 600px; max-height: 200px; overflow-y: auto">
                    <div class="datatable" style="background-color: #E1E1E1; padding-bottom: 3px;">
                        <div class="lt">&nbsp;</div>
                        <div class="rt">&nbsp;</div>
                        <div class="lb">&nbsp;</div>
                        <div class="rb">&nbsp;</div>

                        <div style="padding: 4px 0 0 6px;font-size:1.4rem;position:relative;">
                            User lists

                            <div style="position:absolute;right:0.25em;top:0.35em;">
                                <span style="padding:0;position:relative;bottom:2px;" class="rowCount"></span>

                                <img class="closed"
                                    src="./Everything About Dynamic Programming - Codeforces_files/control.png">

                                <span class="filter" style="display:none;">
                                    <img class="opened"
                                        src="./Everything About Dynamic Programming - Codeforces_files/control-270.png">
                                    <input
                                        style="padding:0 0 0 20px;position:relative;bottom:2px;border:1px solid #aaa;height:17px;font-size:1.3rem;">
                                </span>
                            </div>
                        </div>
                        <div style="background-color: white;margin:0.3em 3px 0 3px;position:relative;">
                            <div class="ilt">&nbsp;</div>
                            <div class="irt">&nbsp;</div>
                            <table class="">
                                <thead>
                                    <tr>
                                        <th class="top left right">Name</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr class="no-items visible">
                                        <td style="text-align:left;" colspan="32" class="bottom dark left right">No
                                            items</td>
                                    </tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <script type="text/javascript">
                        $(document).ready(function () {
                            // Create new ':containsIgnoreCase' selector for search
                            jQuery.expr[':'].containsIgnoreCase = function (a, i, m) {
                                return jQuery(a).text().toUpperCase()
                                    .indexOf(m[3].toUpperCase()) >= 0;
                            };

                            if (window.updateDatatableFilter == undefined) {
                                window.updateDatatableFilter = function (i) {
                                    var parent = $(i).parent().parent().parent().parent();
                                    $("tr.no-items", parent).remove();
                                    $("tr", parent).hide().removeClass('visible');
                                    var text = $(i).val();
                                    if (text) {
                                        $("tr" + ":containsIgnoreCase('" + text + "')", parent).show().addClass('visible');
                                    } else {
                                        parent.find(".rowCount").text("");
                                        $("tr", parent).show().addClass('visible');
                                    }

                                    var found = false;
                                    var visibleRowCount = 0;
                                    $("tr", parent).each(function () {
                                        if (!found) {
                                            if ($(this).find("th").size() > 0) {
                                                $(this).show().addClass('visible');
                                                found = true;
                                            }
                                        }
                                        if ($(this).hasClass('visible')) {
                                            visibleRowCount++;
                                        }
                                    });
                                    if (text) {
                                        parent.find(".rowCount").text("Matches: " + (visibleRowCount - (found ? 1 : 0)));
                                    }
                                    if (visibleRowCount == (found ? 1 : 0)) {
                                        $("<tr class='no-items visible'><td style=\"text-align:left;\"colspan=\"32\">No items<\/td><\/tr>").appendTo($(parent).find('table'));
                                    }
                                    $(parent).find("tr td").removeClass("dark");
                                    $(parent).find("tr.visible:odd td").addClass("dark");
                                }

                                $(".datatable .closed").click(function () {
                                    var parent = $(this).parent();
                                    $(this).hide();
                                    $(".filter", parent).fadeIn(function () {
                                        $("input", parent).val("").focus().css("border", "1px solid #aaa");
                                    });
                                });

                                $(".datatable .opened").click(function () {
                                    var parent = $(this).parent().parent();
                                    $(".filter", parent).fadeOut(function () {
                                        $(".closed", parent).show();
                                        $("input", parent).val("").each(function () {
                                            window.updateDatatableFilter(this);
                                        });
                                    });
                                });

                                $(".datatable .filter input").keyup(function (e) {
                                    window.updateDatatableFilter(this);
                                    e.preventDefault();
                                    e.stopPropagation();
                                });

                                $(".datatable table").each(function () {
                                    var found = false;
                                    $("tr", this).each(function () {
                                        if (!found && $(this).find("th").size() == 0) {
                                            found = true;
                                        }
                                    });
                                    if (!found) {
                                        $("<tr class='no-items visible'><td style=\"text-align:left;\"colspan=\"32\">No items<\/td><\/tr>").appendTo(this);
                                    }
                                });

                                // Applies styles to datatables.
                                $(".datatable").each(function () {
                                    $(this).find("tr:first th").addClass("top");
                                    $(this).find("tr:last td").addClass("bottom");
                                    $(this).find("tr:odd td").addClass("dark");
                                    $(this).find("tr td:first-child, tr th:first-child").addClass("left");
                                    $(this).find("tr td:last-child, tr th:last-child").addClass("right");
                                });

                                $(".datatable table.tablesorter").each(function () {
                                    $(this).bind("sortEnd", function () {
                                        $(".datatable").each(function () {
                                            $(this).find("th, td")
                                                .removeClass("top").removeClass("bottom")
                                                .removeClass("left").removeClass("right")
                                                .removeClass("dark");
                                            $(this).find("tr:first th").addClass("top");
                                            $(this).find("tr:last td").addClass("bottom");
                                            $(this).find("tr:odd td").addClass("dark");
                                            $(this).find("tr td:first-child, tr th:first-child").addClass("left");
                                            $(this).find("tr td:last-child, tr th:last-child").addClass("right");
                                        });
                                    });
                                });
                            }
                        });
                    </script>
                </div>
            </div>
            <script type="application/javascript">
                $(function () {
                    $(".userListMarker").click(function () {
                        $.post("/data/lists", { action: "findTouched" }, function (json) {
                            Codeforces.facebox(".userListsFacebox");
                            var tbody = $("#facebox tbody");
                            tbody.empty();
                            for (var i in json) {
                                tbody.append(
                                    $("<tr></tr>").append(
                                        $("<td></td>").attr("data-readKey", json[i].readKey).text(json[i].name)
                                    )
                                );
                            }
                            Codeforces.updateDatatables();
                            tbody.find("td").css("cursor", "pointer").click(function () {
                                document.location = Codeforces.updateUrlParameter(document.location.href, "list", $(this).attr("data-readKey"));
                            });
                        }, "json");
                    });
                });
            </script>
        </div>
        <script type="application/javascript">
            if ('serviceWorker' in navigator && 'fetch' in window && 'caches' in window) {
                var parser = new UAParser();
                var browserName = parser.getBrowser().name;
                var browserVersion = parser.getBrowser().version;

                var supportedBrowser = false;
                var supportedBrowsers = {
                    "Chrome": "76",
                    "Firefox": "68",
                    // "Edge": "18",
                    "Safari": "12.1",
                    "Opera": "63",
                    "Yandex": "19.9"
                };

                for (var name in supportedBrowsers) {
                    if (name === browserName && supportedBrowsers[name] <= browserVersion) {
                        supportedBrowser = true;
                    }
                }

                if (supportedBrowser) {
                    navigator.serviceWorker.register('/service-worker-57914.js')
                        .then(function (registration) {
                            console.log('Service worker registered');
                        })
                        .catch(function (error) {
                            console.log('Registration failed: ', error);
                        });
                } else {
                    navigator.serviceWorker.getRegistrations().then(function (registrations) {
                        for (var i = 0; i < registrations.length; i++) {
                            registrations[i].unregister();
                        }
                    });
                }
            }
        </script>


        <div id="datepick-div" style="display: none;"></div>
        <div id="cboxOverlay" style="display: none;"></div>
        <div id="colorbox" class="" style="display: none; padding-bottom: 42px; padding-right: 42px;">
            <div id="cboxWrapper">
                <div>
                    <div id="cboxTopLeft" style="float: left;"></div>
                    <div id="cboxTopCenter" style="float: left;"></div>
                    <div id="cboxTopRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxMiddleLeft" style="float: left;"></div>
                    <div id="cboxContent" style="float: left;">
                        <div id="cboxLoadedContent" style="width: 0px; height: 0px; overflow: hidden; float: left;">
                        </div>
                        <div id="cboxLoadingOverlay" style="float: left;"></div>
                        <div id="cboxLoadingGraphic" style="float: left;"></div>
                        <div id="cboxTitle" style="float: left;"></div>
                        <div id="cboxCurrent" style="float: left;"></div>
                        <div id="cboxNext" style="float: left;"></div>
                        <div id="cboxPrevious" style="float: left;"></div>
                        <div id="cboxSlideshow" style="float: left;"></div>
                        <div id="cboxClose" style="float: left;"></div>
                    </div>
                    <div id="cboxMiddleRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxBottomLeft" style="float: left;"></div>
                    <div id="cboxBottomCenter" style="float: left;"></div>
                    <div id="cboxBottomRight" style="float: left;"></div>
                </div>
            </div>
            <div style="position: absolute; width: 9999px; visibility: hidden; display: none;"></div>
        </div>
        <div
            style="position: absolute; width: 0px; height: 0px; overflow: hidden; padding: 0px; border: 0px; margin: 0px;">
            <div id="MathJax_Font_Test"
                style="position: absolute; visibility: hidden; top: 0px; left: 0px; width: auto; min-width: 0px; max-width: none; padding: 0px; border: 0px; margin: 0px; white-space: nowrap; text-align: left; text-indent: 0px; text-transform: none; line-height: normal; letter-spacing: normal; word-spacing: normal; font-size: 40px; font-weight: normal; font-style: normal; font-family: MathJax_Size1, monospace;">
            </div>
        </div>
        <div id="datepick-div" style="display: none;"></div>
        <div id="cboxOverlay" style="display: none;"></div>
        <div id="colorbox" class="" style="display: none;">
            <div id="cboxWrapper">
                <div>
                    <div id="cboxTopLeft" style="float: left;"></div>
                    <div id="cboxTopCenter" style="float: left;"></div>
                    <div id="cboxTopRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxMiddleLeft" style="float: left;"></div>
                    <div id="cboxContent" style="float: left;">
                        <div id="cboxLoadedContent" style="width: 0px; height: 0px; overflow: hidden; float: left;">
                        </div>
                        <div id="cboxLoadingOverlay" style="float: left;"></div>
                        <div id="cboxLoadingGraphic" style="float: left;"></div>
                        <div id="cboxTitle" style="float: left;"></div>
                        <div id="cboxCurrent" style="float: left;"></div>
                        <div id="cboxNext" style="float: left;"></div>
                        <div id="cboxPrevious" style="float: left;"></div>
                        <div id="cboxSlideshow" style="float: left;"></div>
                        <div id="cboxClose" style="float: left;"></div>
                    </div>
                    <div id="cboxMiddleRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxBottomLeft" style="float: left;"></div>
                    <div id="cboxBottomCenter" style="float: left;"></div>
                    <div id="cboxBottomRight" style="float: left;"></div>
                </div>
            </div>
            <div style="position: absolute; width: 9999px; visibility: hidden; display: none;"></div>
        </div>


        <div id="datepick-div" style="display: none;"></div>
        <div id="cboxOverlay" style="display: none;"></div>
        <div id="colorbox" class="" style="display: none;">
            <div id="cboxWrapper">
                <div>
                    <div id="cboxTopLeft" style="float: left;"></div>
                    <div id="cboxTopCenter" style="float: left;"></div>
                    <div id="cboxTopRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxMiddleLeft" style="float: left;"></div>
                    <div id="cboxContent" style="float: left;">
                        <div id="cboxLoadedContent" style="width: 0px; height: 0px; overflow: hidden; float: left;">
                        </div>
                        <div id="cboxLoadingOverlay" style="float: left;"></div>
                        <div id="cboxLoadingGraphic" style="float: left;"></div>
                        <div id="cboxTitle" style="float: left;"></div>
                        <div id="cboxCurrent" style="float: left;"></div>
                        <div id="cboxNext" style="float: left;"></div>
                        <div id="cboxPrevious" style="float: left;"></div>
                        <div id="cboxSlideshow" style="float: left;"></div>
                        <div id="cboxClose" style="float: left;"></div>
                    </div>
                    <div id="cboxMiddleRight" style="float: left;"></div>
                </div>
                <div style="clear: left;">
                    <div id="cboxBottomLeft" style="float: left;"></div>
                    <div id="cboxBottomCenter" style="float: left;"></div>
                    <div id="cboxBottomRight" style="float: left;"></div>
                </div>
            </div>
            <div style="position: absolute; width: 9999px; visibility: hidden; display: none;"></div>
        </div>
    </body>

</html>